generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  schemas  = ["app_v3", "auth"]
  extensions = [citext()]
}

enum NotificationType {
  ORGANIZER_INVITE
  ORGANIZER_TRANSFER
  STAFF_INVITE
  STAFF_ROLE_CHANGE
  EVENT_SALE
  EVENT_PAYOUT_STATUS
  STRIPE_STATUS
  FRIEND_REQUEST
  FRIEND_ACCEPT
  EVENT_REMINDER
  CHECKIN_READY
  TICKET_SHARED
  MARKETING_PROMO_ALERT
  SYSTEM_ANNOUNCE
  FOLLOWED_YOU
  TICKET_TRANSFER_RECEIVED
  TICKET_TRANSFER_ACCEPTED
  TICKET_TRANSFER_DECLINED
  CLUB_INVITE
  NEW_EVENT_FROM_FOLLOWED_ORGANIZER

  @@schema("app_v3")
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH

  @@schema("app_v3")
}

enum OrgType {
  PLATFORM
  EXTERNAL

  @@schema("app_v3")
}

/// Perfil base do utilizador ORYA (1-1 com auth.users)
model Profile {
  id                                     String                  @id @db.Uuid
  username                               String?                 @unique @db.Citext
  fullName                               String?                 @map("full_name")
  avatarUrl                              String?                 @map("avatar_url")
  bio                                    String?
  city                                   String?
  favouriteCategories                    String[]                @default([]) @map("favourite_categories")
  onboardingDone                         Boolean                 @default(false) @map("onboarding_done")
  /// roles do user: ["user"], ["user","organizer"], ["user","admin"], etc.
  roles                                  String[]                @default(["user"])
  createdAt                              DateTime                @default(now()) @map("created_at")
  updatedAt                              DateTime                @default(now()) @updatedAt @map("updated_at")
  allowEmailNotifications                Boolean                 @default(true) @map("allow_email_notifications")
  allowEventReminders                    Boolean                 @default(true) @map("allow_event_reminders")
  allowFriendRequests                    Boolean                 @default(true) @map("allow_friend_requests")
  deletedAt                              DateTime?               @map("deleted_at") @db.Timestamp(6)
  isDeleted                              Boolean                 @default(false) @map("is_deleted")
  visibility                             Visibility              @default(PUBLIC)
  is_verified                            Boolean                 @default(false)
  contactPhone                           String?                 @map("contact_phone")
  follows_follows_follower_idToprofiles  follows[]               @relation("follows_follower_idToprofiles")
  follows_follows_following_idToprofiles follows[]               @relation("follows_following_idToprofiles")
  organizers                             Organizer[]
  organizerMembers                       OrganizerMember[]
  organizerInvitesSent                   OrganizerMemberInvite[] @relation("OrganizerMemberInviteInviter")
  organizerInvitesReceived               OrganizerMemberInvite[] @relation("OrganizerMemberInviteTarget")
  eventsOwned                            Event[]                 @relation("EventOwner")
  padelPairingSlots                      PadelPairingSlot[]
  notifications                          Notification[]
  notificationsSent                      Notification[]         @relation("NotificationSender")
  notificationPreference                 NotificationPreference?
  saleSummaries                          SaleSummary[]

  @@map("profiles")
  @@schema("app_v3")
}

/// Entidade organizadora (marca, página de eventos)
model Organizer {
  id                     Int                     @id @default(autoincrement())
  displayName            String                  @map("display_name")
  username               String?                 @unique @db.Citext
  stripeAccountId        String?                 @map("stripe_account_id")
  status                 OrganizerStatus         @default(PENDING)
  createdAt              DateTime                @default(now()) @map("created_at")
  updatedAt              DateTime                @default(now()) @updatedAt @map("updated_at")
  userId                 String?                 @map("user_id") @db.Uuid
  feeMode                FeeMode                 @default(ADDED) @map("fee_mode")
  platformFeeBps         Int                     @default(200) @map("platform_fee_bps")
  platformFeeFixedCents  Int                     @default(0) @map("platform_fee_fixed_cents")
  stripeChargesEnabled   Boolean                 @default(false) @map("stripe_charges_enabled")
  stripePayoutsEnabled   Boolean                 @default(false) @map("stripe_payouts_enabled")
  entityType             String?                 @map("entity_type")
  businessName           String?                 @map("business_name")
  publicName             String?                 @map("public_name")
  city                   String?                 @map("city")
  address                String?                 @map("address")
  showAddressPublicly    Boolean                 @default(false) @map("show_address_publicly")
  payoutIban             String?                 @map("payout_iban")
  language               String?                 @default("pt")
  publicListingEnabled   Boolean                 @default(true) @map("public_listing_enabled")
  alertsEmail            String?                 @map("alerts_email")
  alertsSalesEnabled     Boolean                 @default(true) @map("alerts_sales_enabled")
  alertsPayoutEnabled    Boolean                 @default(false) @map("alerts_payout_enabled")
  orgType                OrgType                 @default(EXTERNAL) @map("org_type")
  officialEmail          String?                 @map("official_email")
  officialEmailVerifiedAt DateTime?              @map("official_email_verified_at")
  refundFeePayer         RefundFeePayer          @default(CUSTOMER) @map("refund_fee_payer")
  brandingAvatarUrl      String?                 @map("branding_avatar_url")
  brandingPrimaryColor   String?                 @map("branding_primary_color")
  brandingSecondaryColor String?                 @map("branding_secondary_color")
  organizationKind       OrganizationKind        @default(PESSOA_SINGULAR) @map("organization_kind")
  padelDefaultShortName  String?                 @map("padel_default_short_name")
  padelDefaultCity       String?                 @map("padel_default_city")
  padelDefaultAddress    String?                 @map("padel_default_address")
  padelDefaultCourts     Int                     @default(0) @map("padel_default_courts")
  padelDefaultHours      String?                 @map("padel_default_hours")
  padelDefaultRuleSetId  Int?                    @map("padel_default_rule_set_id")
  padelFavoriteCategories Int[]                  @default([]) @map("padel_favorite_categories")
  events                 Event[]
  user                   Profile?                @relation(fields: [userId], references: [id], onUpdate: NoAction)
  staffAssignments       StaffAssignment[]
  members                OrganizerMember[]
  ownerTransfers         OrganizerOwnerTransfer[]
  officialEmailRequests  OrganizerOfficialEmailRequest[]
  auditLogs              OrganizationAuditLog[]
  padelPlayers           PadelPlayerProfile[]
  padelCategories        PadelCategory[]
  padelRuleSets          PadelRuleSet[]          @relation("OrganizerPadelRuleSets")
  padelTournaments       PadelTournamentConfig[]
  padelRankingEntries    PadelRankingEntry[]
  padelPairings          PadelPairing[]
  padelClubs             PadelClub[]
  memberInvites          OrganizerMemberInvite[]
  notifications          Notification[]          @relation("NotificationOrganizer")
  padelDefaultRuleSet    PadelRuleSet?           @relation("OrganizerPadelDefaultRuleSet", fields: [padelDefaultRuleSetId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@map("organizers")
  @@schema("app_v3")
}

model GlobalUsername {
  username  String   @id @db.Citext
  ownerType String   @map("owner_type")
  ownerId   String   @map("owner_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  @@unique([ownerType, ownerId])
  @@map("global_usernames")
  @@schema("app_v3")
}

model Notification {
  id        String               @id @default(uuid()) @db.Uuid
  userId    String               @map("user_id") @db.Uuid
  type      NotificationType
  title     String?
  body      String?
  payload   Json?                @default("{}")
  ctaUrl    String?              @map("cta_url")
  ctaLabel  String?              @map("cta_label")
  priority  NotificationPriority @default(NORMAL)
  fromUserId String?             @map("from_user_id") @db.Uuid
  organizerId Int?               @map("organizer_id")
  eventId    Int?                @map("event_id")
  ticketId   String?             @map("ticket_id")
  inviteId   String?             @map("invite_id") @db.Uuid
  isRead     Boolean             @default(false) @map("is_read")
  readAt     DateTime?           @map("read_at")
  seenAt     DateTime?           @map("seen_at")
  expiresAt  DateTime?           @map("expires_at")
  createdAt  DateTime            @default(now()) @map("created_at")

  user      Profile                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  fromUser  Profile?                 @relation("NotificationSender", fields: [fromUserId], references: [id], onDelete: SetNull)
  organizer Organizer?               @relation("NotificationOrganizer", fields: [organizerId], references: [id], onDelete: SetNull)
  event     Event?                   @relation("NotificationEvent", fields: [eventId], references: [id], onDelete: SetNull)
  ticket    Ticket?                  @relation("NotificationTicket", fields: [ticketId], references: [id], onDelete: SetNull)
  invite    OrganizerMemberInvite?   @relation("NotificationInvite", fields: [inviteId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([userId, readAt])
  @@index([fromUserId])
  @@index([organizerId])
  @@index([eventId])
  @@index([ticketId])
  @@index([inviteId])
  @@map("notifications")
  @@schema("app_v3")
}

model NotificationPreference {
  userId                   String   @id @db.Uuid
  allowEmailNotifications  Boolean  @default(true) @map("allow_email_notifications")
  allowEventReminders      Boolean  @default(true) @map("allow_event_reminders")
  allowFriendRequests      Boolean  @default(true) @map("allow_friend_requests")
  allowSalesAlerts         Boolean  @default(true) @map("allow_sales_alerts")
  allowSystemAnnouncements Boolean  @default(true) @map("allow_system_announcements")
  createdAt                DateTime @default(now()) @map("created_at")
  updatedAt                DateTime @default(now()) @updatedAt @map("updated_at")

  user Profile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
  @@schema("app_v3")
}

enum OrganizerMemberRole {
  OWNER
  CO_OWNER
  ADMIN
  STAFF
  VIEWER

  @@schema("app_v3")
}

enum OrganizerOwnerTransferStatus {
  PENDING
  CONFIRMED
  CANCELLED
  EXPIRED

  @@schema("app_v3")
}

enum OrganizerEmailRequestStatus {
  PENDING
  CONFIRMED
  CANCELLED
  EXPIRED

  @@schema("app_v3")
}

model OrganizerMember {
  id              String              @id @default(uuid()) @db.Uuid
  organizerId     Int                 @map("organizer_id")
  userId          String              @map("user_id") @db.Uuid
  role            OrganizerMemberRole
  invitedByUserId String?             @map("invited_by_user_id") @db.Uuid
  lastUsedAt      DateTime?           @map("last_used_at")
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @default(now()) @map("updated_at")

  organizer Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  user      Profile   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizerId, userId])
  @@index([userId])
  @@index([organizerId, role])
  @@map("organizer_members")
  @@schema("app_v3")
}

model OrganizerMemberInvite {
  id               String              @id @default(uuid()) @db.Uuid
  organizerId      Int                 @map("organizer_id")
  invitedByUserId  String              @map("invited_by_user_id") @db.Uuid
  targetIdentifier String              @map("target_identifier") @db.Citext
  targetUserId     String?             @map("target_user_id") @db.Uuid
  role             OrganizerMemberRole
  token            String              @unique @db.Uuid
  expiresAt        DateTime            @map("expires_at")
  acceptedAt       DateTime?           @map("accepted_at")
  declinedAt       DateTime?           @map("declined_at")
  cancelledAt      DateTime?           @map("cancelled_at")
  createdAt        DateTime            @default(now()) @map("created_at")
  updatedAt        DateTime            @default(now()) @updatedAt @map("updated_at")

  organizer  Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  invitedBy  Profile   @relation("OrganizerMemberInviteInviter", fields: [invitedByUserId], references: [id], onDelete: Cascade)
  targetUser Profile?  @relation("OrganizerMemberInviteTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  notifications Notification[] @relation("NotificationInvite")

  @@index([organizerId])
  @@index([targetUserId])
  @@index([targetIdentifier])
  @@map("organizer_member_invites")
  @@schema("app_v3")
}

model OrganizerOwnerTransfer {
  id           String                         @id @default(uuid()) @db.Uuid
  organizerId  Int                            @map("organizer_id")
  fromUserId   String                         @map("from_user_id") @db.Uuid
  toUserId     String                         @map("to_user_id") @db.Uuid
  status       OrganizerOwnerTransferStatus   @default(PENDING)
  token        String                         @unique
  expiresAt    DateTime                       @map("expires_at")
  createdAt    DateTime                       @default(now()) @map("created_at")
  confirmedAt  DateTime?                      @map("confirmed_at")
  cancelledAt  DateTime?                      @map("cancelled_at")

  organizer    Organizer                      @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([organizerId])
  @@index([fromUserId])
  @@index([toUserId])
  @@map("organization_owner_transfers")
  @@schema("app_v3")
}

model OrganizerOfficialEmailRequest {
  id                 String                        @id @default(uuid()) @db.Uuid
  organizerId        Int                           @map("organizer_id")
  requestedByUserId  String                        @map("requested_by_user_id") @db.Uuid
  newEmail           String                        @map("new_email")
  token              String                        @unique
  status             OrganizerEmailRequestStatus   @default(PENDING)
  expiresAt          DateTime                      @map("expires_at")
  createdAt          DateTime                      @default(now()) @map("created_at")
  confirmedAt        DateTime?                     @map("confirmed_at")
  cancelledAt        DateTime?                     @map("cancelled_at")

  organizer          Organizer                     @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([organizerId])
  @@index([requestedByUserId])
  @@map("organizer_official_email_requests")
  @@schema("app_v3")
}

model OrganizationAuditLog {
  id           String   @id @default(uuid()) @db.Uuid
  organizerId  Int      @map("organizer_id")
  actorUserId  String?  @map("actor_user_id") @db.Uuid
  action       String
  fromUserId   String?  @map("from_user_id") @db.Uuid
  toUserId     String?  @map("to_user_id") @db.Uuid
  metadata     Json?    @default("{}")
  ip           String?
  userAgent    String?  @map("user_agent")
  createdAt    DateTime @default(now()) @map("created_at")

  organizer    Organizer @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([organizerId])
  @@index([actorUserId])
  @@map("organization_audit_logs")
  @@schema("app_v3")
}

/// Evento/Experiência — único tipo com campo `type` a separar
model Event {
  id                                Int                     @id @default(autoincrement())
  slug                              String                  @unique
  title                             String
  description                       String
  /// "EXPERIENCE" (user) ou "ORGANIZER_EVENT" (organizador)
  type                              EventType               @default(EXPERIENCE)
  /// Template de apoio (festa, desporto, voluntariado, palestra...)
  templateType                      EventTemplateType?      @map("template_type")
  /// Liga ao Organizer quando é evento de organizador
  organizerId                       Int?                    @map("organizer_id")
  startsAt                          DateTime                @map("starts_at")
  endsAt                            DateTime                @map("ends_at")
  locationName                      String                  @map("location_name")
  locationCity                      String?                 @map("location_city")
  address                           String?
  latitude                          Float?                  @map("lat")
  longitude                         Float?                  @map("lng")
  isFree                            Boolean                 @default(false) @map("is_free")
  status                            EventStatus             @default(DRAFT)
  timezone                          String                  @default("Europe/Lisbon")
  coverImageUrl                     String?                 @map("cover_image_url")
  createdAt                         DateTime                @default(now()) @map("created_at")
  updatedAt                         DateTime                @updatedAt @map("updated_at")
  /// auth.users.id de quem criou (user base)
  ownerUserId                       String                  @map("owner_user_id") @db.Uuid
  deletedAt                         DateTime?               @map("deleted_at") @db.Timestamp(6)
  isDeleted                         Boolean                 @default(false) @map("is_deleted")
  resaleMode                        ResaleMode              @default(ALWAYS) @map("resale_mode")
  fee_mode_override                 FeeMode?
  platform_fee_bps_override         Int?
  platform_fee_fixed_cents_override Int?
  feeMode                           FeeMode                 @default(INCLUDED) @map("fee_mode")
  isTest                            Boolean                 @default(false) @map("is_test")
  payoutMode                        PayoutMode              @default(ORGANIZER) @map("payout_mode")
  categories                        EventCategory[]
  interests                         EventInterest[]
  salesAgg                          EventSalesAgg?
  views                             EventView[]
  organizer                         Organizer?              @relation(fields: [organizerId], references: [id])
  owner                             Profile                 @relation("EventOwner", fields: [ownerUserId], references: [id])
  participants                      ExperienceParticipant[]
  promoCodes                        PromoCode[]
  staffAssignments                  StaffAssignment[]
  reservations                      TicketReservation[]
  ticketTypes                       TicketType[]
  tickets                           Ticket[]
  ticketCheckins                    TicketCheckin[]
  padelTournamentConfig             PadelTournamentConfig?
  padelTeams                        PadelTeam[]
  padelMatches                      PadelMatch[]
  padelRankingEntries               PadelRankingEntry[]
  padelPairings                     PadelPairing[]
  saleSummaries                     SaleSummary[]
  saleLines                         SaleLine[]
  notifications                     Notification[]          @relation("NotificationEvent")

  @@index([type, status])
  @@index([ownerUserId])
  @@index([ownerUserId, startsAt])
  @@index([organizerId])
  @@map("events")
  @@schema("app_v3")
}

/// Junção N-N de eventos a categorias
model EventCategory {
  id        Int               @id @default(autoincrement())
  eventId   Int               @map("event_id")
  category  EventCategoryType
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  event     Event             @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "event_categories_event_fk")

  @@unique([eventId, category], map: "event_categories_unique")
  @@index([category])
  @@map("event_categories")
  @@schema("app_v3")
}

/// Tipos de bilhete (antigas "waves")
model TicketType {
  id            Int                 @id @default(autoincrement())
  eventId       Int
  name          String
  description   String?
  price         Int
  currency      String              @default("EUR")
  totalQuantity Int?                @map("total_quantity")
  soldQuantity  Int                 @default(0) @map("sold_quantity")
  status        TicketTypeStatus    @default(ON_SALE)
  startsAt      DateTime?           @map("starts_at")
  endsAt        DateTime?           @map("ends_at")
  sortOrder     Int                 @default(0) @map("sort_order")
  createdAt     DateTime            @default(now()) @map("created_at")
  updatedAt     DateTime            @updatedAt @map("updated_at")
  reservations  TicketReservation[]
  event         Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets       Ticket[]
  saleLines     SaleLine[]

  @@index([eventId])
  @@map("ticket_types")
  @@schema("app_v3")
}

/// Bilhete individual (por utilizador)
model Ticket {
  id                    String            @id @default(cuid())
  eventId               Int
  ticketTypeId          Int               @map("ticket_type_id")
  purchasedAt           DateTime          @default(now()) @map("purchased_at")
  status                TicketStatus      @default(ACTIVE)
  qrSecret              String            @unique @map("qr_secret")
  rotatingSeed          String?           @map("rotating_seed") @db.Uuid
  pricePaid             Int               @map("price_paid")
  currency              String            @default("EUR")
  stripePaymentIntentId String?           @map("stripe_payment_intent_id")
  usedAt                DateTime?         @map("used_at")
  userId                String?           @map("user_id") @db.Uuid
  platformFeeCents      Int               @default(0) @map("platform_fee_cents")
  totalPaidCents        Int               @default(0) @map("total_paid_cents")
  pairingId             Int?              @map("pairing_id")
  padelSplitShareCents  Int?              @map("padel_split_share_cents")
  padelPairingVersion   Int?              @map("padel_pairing_version")
  guestLink             GuestTicketLink?
  resales               TicketResale[]
  transfers             TicketTransfer[]
  createdPadelPairings  PadelPairing[]    @relation("PadelPairingCreatedByTicket")
  pairing               PadelPairing?     @relation("PairingTickets", fields: [pairingId], references: [id], onDelete: SetNull)
  pairingSlot           PadelPairingSlot? @relation("TicketPairingSlot")
  event                 Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  ticketType            TicketType        @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)
  notifications         Notification[]    @relation("NotificationTicket")
  checkins              TicketCheckin[]

  @@index([eventId])
  @@index([userId])
  @@index([ticketTypeId])
  @@index([stripePaymentIntentId])
  @@index([pairingId])
  @@map("tickets")
  @@schema("app_v3")
}

model TicketCheckin {
  id           String    @id @default(uuid()) @db.Uuid
  ticketId     String    @map("ticket_id")
  eventId      Int       @map("event_id")
  staffUserId  String?   @map("staff_user_id") @db.Uuid
  deviceId     String?   @map("device_id")
  createdAt    DateTime  @default(now()) @map("created_at")

  ticket       Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  event        Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([ticketId])
  @@index([staffUserId])
  @@map("ticket_checkins")
  @@schema("app_v3")
}

/// Ligação de bilhetes comprados como convidado
/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model GuestTicketLink {
  ticketId         String    @id @map("ticket_id")
  guestEmail       String    @map("guest_email")
  guestName        String    @map("guest_name")
  guestPhone       String?   @map("guest_phone")
  migratedToUserId String?   @map("migrated_to_user_id") @db.Uuid
  migratedAt       DateTime? @map("migrated_at") @db.Timestamptz(6)
  createdAt        DateTime? @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt        DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  ticket           Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([migratedToUserId], map: "guest_ticket_links_migrated_idx")
  @@map("guest_ticket_links")
  @@schema("app_v3")
}

/// Reservas temporárias de stock de bilhetes
model TicketReservation {
  id           String            @id @default(cuid())
  eventId      Int
  ticketTypeId Int               @map("ticket_type_id")
  quantity     Int
  status       ReservationStatus @default(ACTIVE)
  expiresAt    DateTime          @map("expires_at")
  createdAt    DateTime          @default(now()) @map("created_at")
  updatedAt    DateTime          @updatedAt @map("updated_at")
  userId       String?           @map("user_id") @db.Uuid
  event        Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  ticketType   TicketType        @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([ticketTypeId])
  @@index([userId])
  @@index([status, expiresAt])
  @@map("ticket_reservations")
  @@schema("app_v3")
}

/// Participantes em experiências (sem QR / bilhete)
model ExperienceParticipant {
  id                String   @id @default(cuid())
  eventId           Int
  createdAt         DateTime @default(now()) @map("created_at")
  userId            String   @db.Uuid
  volunteer_minutes Int?
  event             Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId])
  @@map("experience_participants")
  @@schema("app_v3")
}

/// Interesse / "quero ir" em eventos de organizador
model EventInterest {
  id        String   @id @default(cuid())
  eventId   Int
  createdAt DateTime @default(now()) @map("created_at")
  userId    String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId])
  @@map("event_interests")
  @@schema("app_v3")
}

/// Staff associado a organizadores / eventos
model StaffAssignment {
  id          Int         @id @default(autoincrement())
  organizerId Int         @map("organizer_id")
  scope       StaffScope
  eventId     Int?        @map("event_id")
  createdAt   DateTime    @default(now()) @map("created_at")
  revokedAt   DateTime?   @map("revoked_at")
  userId      String      @map("user_id") @db.Uuid
  acceptedAt  DateTime?   @map("accepted_at") @db.Timestamp(6)
  status      StaffStatus @default(PENDING)
  role        StaffRole   @default(STAFF)
  event       Event?      @relation(fields: [eventId], references: [id])
  organizer   Organizer   @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  @@index([organizerId])
  @@index([userId])
  @@index([eventId])
  @@map("staff_assignments")
  @@schema("app_v3")
}

/// Transferência de bilhetes entre utilizadores
model TicketTransfer {
  id          String         @id @default(cuid())
  ticketId    String         @map("ticket_id")
  status      TransferStatus @default(PENDING)
  createdAt   DateTime       @default(now()) @map("created_at")
  completedAt DateTime?      @map("completed_at")
  fromUserId  String         @map("from_user_id") @db.Uuid
  toUserId    String         @map("to_user_id") @db.Uuid
  ticket      Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([fromUserId])
  @@index([toUserId])
  @@map("ticket_transfers")
  @@schema("app_v3")
}

/// Revenda de bilhetes pelo utilizador
model TicketResale {
  id           String       @id @default(cuid())
  ticketId     String       @map("ticket_id")
  price        Int
  currency     String       @default("EUR")
  status       ResaleStatus @default(LISTED)
  createdAt    DateTime     @default(now()) @map("created_at")
  completedAt  DateTime?    @map("completed_at")
  sellerUserId String       @map("seller_user_id") @db.Uuid
  ticket       Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([sellerUserId])
  @@map("ticket_resales")
  @@schema("app_v3")
}

/// Pageviews por evento (simples, para futuras stats)
model EventView {
  id        String   @id @default(cuid())
  eventId   Int
  sessionId String?  @map("session_id")
  createdAt DateTime @default(now()) @map("created_at")
  userId    String?  @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([userId])
  @@map("event_views")
  @@schema("app_v3")
}

/// Agregado diário de vendas por evento
model EventSalesAgg {
  id          Int      @id @default(autoincrement())
  eventId     Int      @unique
  date        DateTime @map("date")
  ticketsSold Int      @default(0) @map("tickets_sold")
  revenue     Int      @default(0) @map("revenue")
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_sales_agg")
  @@schema("app_v3")
}

/// Registo de eventos de pagamento (auditoria webhooks/intent)
model PaymentEvent {
  id                    Int       @id @default(autoincrement())
  stripePaymentIntentId String    @unique @map("stripe_payment_intent_id")
  status                String    @default("PROCESSING")
  mode                  PaymentMode @default(LIVE)
  isTest                Boolean   @default(false) @map("is_test")
  eventId               Int?      @map("event_id")
  userId                String?   @map("user_id") @db.Uuid
  amountCents           Int?      @map("amount_cents")
  platformFeeCents      Int?      @map("platform_fee_cents")
  errorMessage          String?   @map("error_message")
  createdAt             DateTime? @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@index([stripePaymentIntentId])
  @@index([eventId])
  @@map("payment_events")
  @@schema("app_v3")
}

enum PaymentMode {
  LIVE
  TEST

  @@schema("app_v3")
}

/// Configurações simples chave-valor (taxas, etc.)
model PlatformSetting {
  id        Int       @id @default(autoincrement())
  key       String    @unique(map: "platform_settings_key_idx")
  value     String
  createdAt DateTime? @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime? @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  @@map("platform_settings")
  @@schema("app_v3")
}

/// Códigos promocionais simples
/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model PromoCode {
  id            Int               @id @default(autoincrement())
  code          String
  type          PromoType
  value         Int
  maxUses       Int?              @map("max_uses")
  perUserLimit  Int?              @map("per_user_limit")
  validFrom     DateTime?         @map("valid_from") @db.Timestamptz(6)
  validUntil    DateTime?         @map("valid_until") @db.Timestamptz(6)
  active        Boolean           @default(true)
  eventId       Int?              @map("event_id")
  createdAt     DateTime          @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt     DateTime          @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  autoApply     Boolean?          @default(false) @map("auto_apply")
  minQuantity   Int?              @map("min_quantity")
  minTotalCents Int?              @map("min_total_cents")
  event         Event?            @relation(fields: [eventId], references: [id], onUpdate: NoAction, map: "promo_codes_event_fk")
  redemptions   PromoRedemption[]
  saleSummaries SaleSummary[]
  saleLines     SaleLine[]

  @@index([eventId])
  @@index([eventId, active], map: "promo_codes_event_active_idx")
  @@index([validFrom, validUntil], map: "promo_codes_valid_idx")
  @@map("promo_codes")
  @@schema("app_v3")
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model PromoRedemption {
  id          Int       @id @default(autoincrement())
  promoCodeId Int       @map("promo_code_id")
  userId      String?   @map("user_id") @db.Uuid
  guestEmail  String?   @map("guest_email")
  usedAt      DateTime  @default(now()) @map("used_at") @db.Timestamptz(6)
  promoCode   PromoCode @relation(fields: [promoCodeId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([promoCodeId], map: "promo_redemptions_code_idx")
  @@index([promoCodeId], map: "promo_redemptions_promo_idx")
  @@index([userId], map: "promo_redemptions_user_idx")
  @@map("promo_redemptions")
  @@schema("app_v3")
}

/// Venda agregada por PaymentIntent (fonte de verdade de valores)
model SaleSummary {
  id                Int       @id @default(autoincrement())
  paymentIntentId   String    @unique @map("payment_intent_id")
  eventId           Int       @map("event_id")
  userId            String?   @map("user_id") @db.Uuid
  promoCodeId       Int?      @map("promo_code_id")
  promoCodeSnapshot String?   @map("promo_code_snapshot")
  promoLabelSnapshot String?  @map("promo_label_snapshot")
  promoTypeSnapshot  PromoType? @map("promo_type_snapshot")
  promoValueSnapshot Int?     @map("promo_value_snapshot")
  subtotalCents     Int       @map("subtotal_cents")
  discountCents     Int       @map("discount_cents")
  platformFeeCents  Int       @map("platform_fee_cents")
  totalCents        Int       @map("total_cents")
  netCents          Int       @map("net_cents")
  feeMode           FeeMode?  @map("fee_mode")
  currency          String    @default("EUR")
  createdAt         DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt         DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  promoCode         PromoCode? @relation(fields: [promoCodeId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  event             Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user              Profile?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  lines             SaleLine[]

  @@index([eventId])
  @@index([userId])
  @@index([promoCodeId])
  @@map("sale_summaries")
  @@schema("app_v3")
}

/// Linhas de venda por tipo de bilhete (para analytics, promo e fees)
model SaleLine {
  id                    Int       @id @default(autoincrement())
  saleSummaryId         Int       @map("sale_summary_id")
  eventId               Int       @map("event_id")
  ticketTypeId          Int       @map("ticket_type_id")
  promoCodeId           Int?      @map("promo_code_id")
  promoCodeSnapshot     String?   @map("promo_code_snapshot")
  promoLabelSnapshot    String?   @map("promo_label_snapshot")
  promoTypeSnapshot     PromoType? @map("promo_type_snapshot")
  promoValueSnapshot    Int?      @map("promo_value_snapshot")
  quantity              Int
  unitPriceCents        Int       @map("unit_price_cents")
  discountPerUnitCents  Int       @default(0) @map("discount_per_unit_cents")
  grossCents            Int       @map("gross_cents")
  netCents              Int       @map("net_cents")
  platformFeeCents      Int       @default(0) @map("platform_fee_cents")
  createdAt             DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  saleSummary           SaleSummary @relation(fields: [saleSummaryId], references: [id], onDelete: Cascade)
  event                 Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  ticketType            TicketType  @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)
  promoCode             PromoCode?  @relation(fields: [promoCodeId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@index([saleSummaryId])
  @@index([eventId])
  @@index([ticketTypeId])
  @@index([promoCodeId])
  @@map("sale_lines")
  @@schema("app_v3")
}

/// Padel MVP: perfis de jogadores do clube
model PadelPlayerProfile {
  id          Int      @id @default(autoincrement())
  organizerId Int      @map("organizer_id")
  userId      String?  @map("user_id") @db.Uuid
  displayName String?  @map("display_name")
  fullName    String   @map("full_name")
  email       String?  @db.Citext
  phone       String?
  gender      String?
  level       String?
  preferredSide PadelPreferredSide? @map("preferred_side")
  clubName    String?  @map("club_name")
  birthDate   DateTime? @map("birth_date")
  isActive    Boolean  @default(true) @map("is_active")
  notes       String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  organizer Organizer           @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  teams1    PadelTeam[]         @relation("PadelTeamPlayer1")
  teams2    PadelTeam[]         @relation("PadelTeamPlayer2")
  rankings  PadelRankingEntry[]
  pairingSlots PadelPairingSlot[]

  @@unique([organizerId, email], map: "padel_player_profiles_uniq_email")
  @@map("padel_player_profiles")
  @@schema("app_v3")
}

/// Clubes de Padel por organizador
model PadelClub {
  id                   Int      @id @default(autoincrement())
  organizerId          Int      @map("organizer_id")
  name                 String
  shortName            String?  @map("short_name")
  city                 String?
  address              String?
  courtsCount          Int      @default(1) @map("courts_count")
  hours                String?
  favoriteCategoryIds  Int[]    @default([]) @map("favorite_category_ids")
  slug                 String?  @unique
  isActive             Boolean  @default(true) @map("is_active")
  isDefault            Boolean  @default(false) @map("is_default")
  deletedAt            DateTime? @map("deleted_at") @db.Timestamp(6)
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @default(now()) @updatedAt @map("updated_at")

  organizer            Organizer             @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  tournaments          PadelTournamentConfig[]
  courts               PadelClubCourt[]
  staff                PadelClubStaff[]

  @@index([organizerId])
  @@map("padel_clubs")
  @@schema("app_v3")
}

model PadelClubCourt {
  id            Int      @id @default(autoincrement())
  padelClubId   Int      @map("padel_club_id")
  name          String
  description   String?
  surface       String?
  indoor        Boolean  @default(false)
  isActive      Boolean  @default(true) @map("is_active")
  displayOrder  Int      @default(0) @map("display_order")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  club PadelClub @relation(fields: [padelClubId], references: [id], onDelete: Cascade)

  @@index([padelClubId])
  @@map("padel_club_courts")
  @@schema("app_v3")
}

model PadelClubStaff {
  id           Int      @id @default(autoincrement())
  padelClubId  Int      @map("padel_club_id")
  userId       String?  @map("user_id") @db.Uuid
  email        String?  @db.Citext
  role         String
  inheritToEvents Boolean @default(true) @map("inherit_to_events")
  isActive     Boolean  @default(true) @map("is_active")
  deletedAt    DateTime? @map("deleted_at") @db.Timestamp(6)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")

  club PadelClub @relation(fields: [padelClubId], references: [id], onDelete: Cascade)

  @@index([padelClubId])
  @@map("padel_club_staff")
  @@schema("app_v3")
}

enum PadelPreferredSide {
  ESQUERDA
  DIREITA
  QUALQUER

  @@schema("app_v3")
}

/// Categorias / níveis de Padel
model PadelCategory {
  id                Int      @id @default(autoincrement())
  organizerId       Int      @map("organizer_id")
  label             String
  genderRestriction String?  @map("gender_restriction")
  minLevel          String?  @map("min_level")
  maxLevel          String?  @map("max_level")
  isDefault         Boolean  @default(false) @map("is_default")
  isActive          Boolean  @default(true) @map("is_active")
  season            String?
  year              Int?
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")

  organizer         Organizer               @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  tournamentConfigs PadelTournamentConfig[]
  teams             PadelTeam[]
  matches           PadelMatch[]
  pairings          PadelPairing[]

  @@map("padel_categories")
  @@schema("app_v3")
}

/// Regras base + tabela de pontos por clube
model PadelRuleSet {
  id             Int      @id @default(autoincrement())
  organizerId    Int      @map("organizer_id")
  name           String
  tieBreakRules  Json     @default("{}") @map("tie_break_rules")
  pointsTable    Json     @default("{}") @map("points_table")
  enabledFormats String[] @default(["TODOS_CONTRA_TODOS", "QUADRO_ELIMINATORIO"]) @map("enabled_formats")
  season         String?
  year           Int?
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  organizer   Organizer               @relation("OrganizerPadelRuleSets", fields: [organizerId], references: [id], onDelete: Cascade)
  defaultForOrganizers Organizer[]    @relation("OrganizerPadelDefaultRuleSet")
  tournaments PadelTournamentConfig[]

  @@map("padel_rule_sets")
  @@schema("app_v3")
}

/// Configuração específica do torneio Padel (por evento)
model PadelTournamentConfig {
  id                 Int               @id @default(autoincrement())
  eventId            Int               @map("event_id")
  organizerId        Int               @map("organizer_id")
  padelClubId        Int?              @map("padel_club_id")
  partnerClubIds     Int[]             @default([]) @map("partner_club_ids")
  format             PadelFormat
  numberOfCourts     Int               @default(1) @map("number_of_courts")
  clubHours          String?           @map("club_hours")
  ruleSetId          Int?              @map("rule_set_id")
  defaultCategoryId  Int?              @map("default_category_id")
  enabledFormats     String[]          @default([]) @map("enabled_formats")
  padelV2Enabled     Boolean           @default(false) @map("padel_v2_enabled")
  advancedSettings   Json?             @map("advanced_settings")
  splitDeadlineHours Int?              @map("split_deadline_hours")
  autoCancelUnpaid   Boolean           @default(true) @map("auto_cancel_unpaid")
  allowCaptainAssume Boolean           @default(true) @map("allow_captain_assume")
  defaultPaymentMode PadelPaymentMode? @map("default_payment_mode")
  refundFeePayer     RefundFeePayer?   @map("refund_fee_payer")
  createdAt          DateTime          @default(now()) @map("created_at")
  updatedAt          DateTime          @default(now()) @updatedAt @map("updated_at")

  event     Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  organizer Organizer      @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  club      PadelClub?     @relation(fields: [padelClubId], references: [id], onDelete: SetNull)
  ruleSet   PadelRuleSet?  @relation(fields: [ruleSetId], references: [id], onDelete: SetNull)
  category  PadelCategory? @relation(fields: [defaultCategoryId], references: [id], onDelete: SetNull)

  @@unique([eventId])
  @@index([padelClubId])
  @@map("padel_tournament_configs")
  @@schema("app_v3")
}

/// Pairings (duplas) para Padel v2
model PadelPairing {
  id                Int                @id @default(autoincrement())
  eventId           Int                @map("event_id")
  organizerId       Int                @map("organizer_id")
  categoryId        Int?               @map("category_id")
  paymentMode       PadelPaymentMode
  pairingStatus     PadelPairingStatus @default(INCOMPLETE) @map("pairing_status")
  createdByUserId   String?            @map("created_by_user_id") @db.Uuid
  createdByTicketId String?            @map("created_by_ticket_id")
  inviteToken       String?            @unique @map("invite_token")
  inviteExpiresAt   DateTime?          @map("invite_expires_at")
  lockedUntil       DateTime?          @map("locked_until")
  isPublicOpen      Boolean            @default(false) @map("is_public_open")
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @default(now()) @updatedAt @map("updated_at")

  event           Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  organizer       Organizer          @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  category        PadelCategory?     @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  createdByTicket Ticket?            @relation("PadelPairingCreatedByTicket", fields: [createdByTicketId], references: [id], onDelete: SetNull)
  slots           PadelPairingSlot[]
  tickets         Ticket[]           @relation("PairingTickets")
  matchesA        PadelMatch[]       @relation("MatchPairingA")
  matchesB        PadelMatch[]       @relation("MatchPairingB")
  matchesWinner   PadelMatch[]       @relation("MatchWinnerPairing")

  @@index([eventId])
  @@index([organizerId])
  @@index([categoryId])
  @@map("padel_pairings")
  @@schema("app_v3")
}

/// Slots de cada pairing (um por jogador)
model PadelPairingSlot {
  id             Int                       @id @default(autoincrement())
  pairingId      Int                       @map("pairing_id")
  ticketId       String?                   @map("ticket_id")
  profileId      String?                   @map("profile_id") @db.Uuid
  playerProfileId Int?                     @map("player_profile_id")
  slotRole       PadelPairingSlotRole
  slotStatus     PadelPairingSlotStatus    @default(PENDING) @map("slot_status")
  paymentStatus  PadelPairingPaymentStatus @default(UNPAID) @map("payment_status")
  invitedContact String?                   @map("invited_contact")
  isPublicOpen   Boolean                   @default(false) @map("is_public_open")
  createdAt      DateTime                  @default(now()) @map("created_at")
  updatedAt      DateTime                  @default(now()) @updatedAt @map("updated_at")

  pairing        PadelPairing       @relation(fields: [pairingId], references: [id], onDelete: Cascade)
  ticket         Ticket?            @relation("TicketPairingSlot", fields: [ticketId], references: [id], onDelete: SetNull)
  profile        Profile?           @relation(fields: [profileId], references: [id], onDelete: SetNull)
  playerProfile  PadelPlayerProfile? @relation(fields: [playerProfileId], references: [id], onDelete: SetNull)

  @@unique([ticketId])
  @@index([pairingId])
  @@index([profileId])
  @@index([playerProfileId])
  @@map("padel_pairing_slots")
  @@schema("app_v3")
}

/// Equipas / duplas
model PadelTeam {
  id                Int      @id @default(autoincrement())
  eventId           Int      @map("event_id")
  categoryId        Int?     @map("category_id")
  player1Id         Int?     @map("player1_id")
  player2Id         Int?     @map("player2_id")
  isFromMatchmaking Boolean  @default(false) @map("is_from_matchmaking")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")

  event    Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  category PadelCategory?      @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  player1  PadelPlayerProfile? @relation("PadelTeamPlayer1", fields: [player1Id], references: [id], onDelete: SetNull)
  player2  PadelPlayerProfile? @relation("PadelTeamPlayer2", fields: [player2Id], references: [id], onDelete: SetNull)
  matchesA PadelMatch[]        @relation("PadelMatchTeamA")
  matchesB PadelMatch[]        @relation("PadelMatchTeamB")

  @@map("padel_teams")
  @@schema("app_v3")
}

/// Jogos
model PadelMatch {
  id          Int              @id @default(autoincrement())
  eventId     Int              @map("event_id")
  categoryId  Int?             @map("category_id")
  courtNumber Int?             @map("court_number")
  courtName   String?          @map("court_name")
  startTime   DateTime?        @map("start_time")
  roundLabel  String?          @map("round_label")
  teamAId     Int?             @map("team_a_id")
  teamBId     Int?             @map("team_b_id")
  score       Json             @default("{}")
  scoreSets   Json?            @map("score_sets")
  pairingAId  Int?             @map("pairing_a_id")
  pairingBId  Int?             @map("pairing_b_id")
  winnerPairingId Int?         @map("winner_pairing_id")
  groupLabel  String?          @map("group_label")
  roundType   String?          @map("round_type")
  status      PadelMatchStatus @default(PENDING)
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @default(now()) @updatedAt @map("updated_at")

  event    Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  category PadelCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  teamA    PadelTeam?     @relation("PadelMatchTeamA", fields: [teamAId], references: [id], onDelete: SetNull)
  teamB    PadelTeam?     @relation("PadelMatchTeamB", fields: [teamBId], references: [id], onDelete: SetNull)
  pairingA PadelPairing?  @relation("MatchPairingA", fields: [pairingAId], references: [id], onDelete: SetNull)
  pairingB PadelPairing?  @relation("MatchPairingB", fields: [pairingBId], references: [id], onDelete: SetNull)
  winnerPairing PadelPairing? @relation("MatchWinnerPairing", fields: [winnerPairingId], references: [id], onDelete: SetNull)

  @@map("padel_matches")
  @@schema("app_v3")
}

/// Ranking básico por torneio/clube
model PadelRankingEntry {
  id          Int      @id @default(autoincrement())
  organizerId Int      @map("organizer_id")
  playerId    Int      @map("player_id")
  eventId     Int      @map("event_id")
  points      Int      @default(0)
  position    Int?
  level       String?
  season      String?
  year        Int?
  createdAt   DateTime @default(now()) @map("created_at")

  organizer Organizer          @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  player    PadelPlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)
  event     Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("padel_ranking_entries")
  @@schema("app_v3")
}

model follows {
  id                                      Int      @id @default(autoincrement())
  follower_id                             String   @db.Uuid
  following_id                            String   @db.Uuid
  created_at                              DateTime @default(now()) @db.Timestamptz(6)
  profiles_follows_follower_idToprofiles  Profile  @relation("follows_follower_idToprofiles", fields: [follower_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  profiles_follows_following_idToprofiles Profile  @relation("follows_following_idToprofiles", fields: [following_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([follower_id, following_id], map: "follows_unique")
  @@index([follower_id], map: "idx_follows_follower")
  @@index([following_id], map: "idx_follows_following")
  @@schema("app_v3")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
enum OrganizerStatus {
  PENDING
  ACTIVE
  SUSPENDED

  @@schema("app_v3")
}

enum EventType {
  EXPERIENCE
  ORGANIZER_EVENT

  @@schema("app_v3")
}

enum Visibility {
  PUBLIC
  PRIVATE

  @@schema("app_v3")
}

enum EventCategoryType {
  FESTA
  DESPORTO
  CONCERTO
  PALESTRA
  ARTE
  COMIDA
  DRINKS

  @@schema("app_v3")
}

enum EventTemplateType {
  PARTY
  SPORT
  PADEL
  VOLUNTEERING
  TALK
  OTHER

  @@schema("app_v3")
}

enum OrganizationKind {
  CLUBE_PADEL
  RESTAURANTE
  EMPRESA_EVENTOS
  ASSOCIACAO
  PESSOA_SINGULAR

  @@schema("app_v3")
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  FINISHED

  @@schema("app_v3")
}

enum ResaleMode {
  ALWAYS
  AFTER_SOLD_OUT
  DISABLED

  @@schema("app_v3")
}

enum PadelFormat {
  TODOS_CONTRA_TODOS
  QUADRO_ELIMINATORIO
  GRUPOS_ELIMINATORIAS
  CAMPEONATO_LIGA
  QUADRO_AB
  NON_STOP

  @@schema("app_v3")
}

enum RefundFeePayer {
  ORGANIZER
  CUSTOMER

  @@schema("app_v3")
}

enum PadelPaymentMode {
  FULL
  SPLIT

  @@schema("app_v3")
}

enum PadelPairingStatus {
  INCOMPLETE
  COMPLETE
  CANCELLED

  @@schema("app_v3")
}

enum PadelPairingSlotStatus {
  PENDING
  FILLED
  CANCELLED

  @@schema("app_v3")
}

enum PadelPairingPaymentStatus {
  UNPAID
  PAID

  @@schema("app_v3")
}

enum PadelPairingSlotRole {
  CAPTAIN
  PARTNER

  @@schema("app_v3")
}

enum PadelMatchStatus {
  PENDING
  IN_PROGRESS
  DONE
  CANCELLED

  @@schema("app_v3")
}

enum FeeMode {
  INCLUDED
  ADDED
  ON_TOP

  @@schema("app_v3")
}

enum PayoutMode {
  ORGANIZER
  PLATFORM

  @@schema("app_v3")
}

enum PromoType {
  PERCENTAGE
  FIXED

  @@schema("app_v3")
}

enum TicketTypeStatus {
  ON_SALE
  UPCOMING
  CLOSED
  SOLD_OUT

  @@schema("app_v3")
}

enum TicketStatus {
  ACTIVE
  USED
  REFUNDED
  TRANSFERRED
  RESALE_LISTED

  @@schema("app_v3")
}

enum ReservationStatus {
  ACTIVE
  COMPLETED
  EXPIRED
  CANCELED

  @@schema("app_v3")
}

enum StaffScope {
  GLOBAL
  EVENT

  @@schema("app_v3")
}

enum StaffRole {
  OWNER
  ADMIN
  STAFF
  CHECKIN

  @@schema("app_v3")
}

enum StaffStatus {
  PENDING
  ACCEPTED
  REVOKED

  @@schema("app_v3")
}

enum TransferStatus {
  PENDING
  ACCEPTED
  CANCELLED

  @@schema("app_v3")
}

enum ResaleStatus {
  LISTED
  SOLD
  CANCELLED

  @@schema("app_v3")
}
