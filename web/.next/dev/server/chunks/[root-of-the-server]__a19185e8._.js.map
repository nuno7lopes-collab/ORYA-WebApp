{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/env.ts"],"sourcesContent":["// Central helper for server-side environment variables (server-only).\n// ⚠️ Não importar este módulo em componentes com \"use client\".\nconst required = [\n  \"SUPABASE_URL\",\n  \"SUPABASE_ANON_KEY\",\n  \"SUPABASE_SERVICE_ROLE\",\n  \"DATABASE_URL\",\n  \"STRIPE_SECRET_KEY\",\n  \"STRIPE_WEBHOOK_SECRET\",\n  \"QR_SECRET_KEY\",\n  \"RESEND_API_KEY\",\n] as const;\n\ntype EnvKey = (typeof required)[number];\n\nfunction getEnv(key: EnvKey): string {\n  const value = process.env[key];\n  if (!value) {\n    throw new Error(`Missing env var: ${key}`);\n  }\n  return value;\n}\n\nfunction getOptionalUrlEnv(...keys: string[]) {\n  for (const key of keys) {\n    const value = process.env[key];\n    if (typeof value === \"string\" && value.trim().length > 0) {\n      return value.trim().replace(/\\/+$/, \"\"); // remove trailing slash para URLs previsíveis\n    }\n  }\n  return \"\";\n}\n\nfunction parseBoolean(raw: unknown, fallback: boolean) {\n  if (typeof raw === \"boolean\") return raw;\n  if (typeof raw === \"string\") {\n    const normalized = raw.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"on\"].includes(normalized)) return true;\n    if ([\"0\", \"false\", \"no\", \"off\"].includes(normalized)) return false;\n  }\n  return fallback;\n}\n\nfunction parseNumber(raw: unknown, fallback: number) {\n  const n = Number(raw);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction parseList(raw: unknown) {\n  if (typeof raw !== \"string\") return [];\n  return raw\n    .split(/[,\\s]+/g)\n    .map((item) => item.trim())\n    .filter(Boolean);\n}\n\nexport const env = {\n  supabaseUrl: getEnv(\"SUPABASE_URL\"),\n  supabaseAnonKey: getEnv(\"SUPABASE_ANON_KEY\"),\n  serviceRoleKey: getEnv(\"SUPABASE_SERVICE_ROLE\"),\n  dbUrl: getEnv(\"DATABASE_URL\"),\n  stripeSecretKey: getEnv(\"STRIPE_SECRET_KEY\"),\n  stripeWebhookSecret: getEnv(\"STRIPE_WEBHOOK_SECRET\"),\n  qrSecretKey: getEnv(\"QR_SECRET_KEY\"),\n  resendApiKey: getEnv(\"RESEND_API_KEY\"),\n  resendFrom:\n    process.env.RESEND_FROM ??\n    process.env.RESEND_FROM_EMAIL ??\n    \"no-reply@orya.pt\",\n  appBaseUrl: getOptionalUrlEnv(\"APP_BASE_URL\", \"NEXT_PUBLIC_BASE_URL\", \"NEXT_PUBLIC_SITE_URL\", \"VERCEL_URL\"),\n  uploadsBucket:\n    process.env.SUPABASE_STORAGE_BUCKET_UPLOADS ??\n    process.env.SUPABASE_STORAGE_BUCKET ??\n    \"uploads\",\n  avatarsBucket: process.env.SUPABASE_STORAGE_BUCKET_AVATARS ?? \"\",\n  eventCoversBucket: process.env.SUPABASE_STORAGE_BUCKET_EVENT_COVERS ?? \"\",\n  storageSignedUrls: parseBoolean(process.env.SUPABASE_STORAGE_SIGNED_URLS, false),\n  storageSignedTtlSeconds: parseNumber(process.env.SUPABASE_STORAGE_SIGNED_TTL_SECONDS, 60 * 60 * 24 * 30), // 30 dias\n  stripePremiumPriceIds: parseList(process.env.STRIPE_PREMIUM_PRICE_IDS),\n  stripePremiumProductIds: parseList(process.env.STRIPE_PREMIUM_PRODUCT_IDS),\n};\n"],"names":[],"mappings":"AAAA,sEAAsE;AACtE,+DAA+D;;;;;AAC/D,MAAM,WAAW;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAID,SAAS,OAAO,GAAW;IACzB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;IAC9B,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK;IAC3C;IACA,OAAO;AACT;AAEA,SAAS,kBAAkB,GAAG,IAAc;IAC1C,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;QAC9B,IAAI,OAAO,UAAU,YAAY,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG;YACxD,OAAO,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,KAAK,8CAA8C;QACzF;IACF;IACA,OAAO;AACT;AAEA,SAAS,aAAa,GAAY,EAAE,QAAiB;IACnD,IAAI,OAAO,QAAQ,WAAW,OAAO;IACrC,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,aAAa,IAAI,IAAI,GAAG,WAAW;QACzC,IAAI;YAAC;YAAK;YAAQ;YAAO;SAAK,CAAC,QAAQ,CAAC,aAAa,OAAO;QAC5D,IAAI;YAAC;YAAK;YAAS;YAAM;SAAM,CAAC,QAAQ,CAAC,aAAa,OAAO;IAC/D;IACA,OAAO;AACT;AAEA,SAAS,YAAY,GAAY,EAAE,QAAgB;IACjD,MAAM,IAAI,OAAO;IACjB,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEA,SAAS,UAAU,GAAY;IAC7B,IAAI,OAAO,QAAQ,UAAU,OAAO,EAAE;IACtC,OAAO,IACJ,KAAK,CAAC,WACN,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI,IACvB,MAAM,CAAC;AACZ;AAEO,MAAM,MAAM;IACjB,aAAa,OAAO;IACpB,iBAAiB,OAAO;IACxB,gBAAgB,OAAO;IACvB,OAAO,OAAO;IACd,iBAAiB,OAAO;IACxB,qBAAqB,OAAO;IAC5B,aAAa,OAAO;IACpB,cAAc,OAAO;IACrB,YACE,QAAQ,GAAG,CAAC,WAAW,IACvB,QAAQ,GAAG,CAAC,iBAAiB,IAC7B;IACF,YAAY,kBAAkB,gBAAgB,wBAAwB,wBAAwB;IAC9F,eACE,QAAQ,GAAG,CAAC,+BAA+B,IAC3C,QAAQ,GAAG,CAAC,uBAAuB,IACnC;IACF,eAAe,QAAQ,GAAG,CAAC,+BAA+B,IAAI;IAC9D,mBAAmB,QAAQ,GAAG,CAAC,oCAAoC,IAAI;IACvE,mBAAmB,aAAa,QAAQ,GAAG,CAAC,4BAA4B,EAAE;IAC1E,yBAAyB,YAAY,QAAQ,GAAG,CAAC,mCAAmC,EAAE,KAAK,KAAK,KAAK;IACrG,uBAAuB,UAAU,QAAQ,GAAG,CAAC,wBAAwB;IACrE,yBAAyB,UAAU,QAAQ,GAAG,CAAC,0BAA0B;AAC3E"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\nimport { Prisma, PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\nimport { env } from \"@/lib/env\";\n\n// Toggle de logs verbose (queries) via env: PRISMA_LOG_QUERIES=true\nconst enableQueryLog = process.env.PRISMA_LOG_QUERIES === \"true\";\nconst logLevels: (Prisma.LogLevel | Prisma.LogDefinition)[] =\n  process.env.NODE_ENV === \"development\"\n    ? enableQueryLog\n      ? [\"query\", \"error\", \"warn\"]\n      : [\"error\", \"warn\"]\n    : [\"error\"];\n\n// Evitar múltiplas instâncias em dev (hot reload)\nconst globalForPrisma = globalThis as unknown as {\n  prisma?: PrismaClient;\n};\n\n// Pool e adapter para usar o client engine (\"library\") com Postgres\nconst pool = new Pool({\n  connectionString: env.dbUrl,\n  ssl:\n    process.env.NODE_ENV === \"production\"\n      ? undefined\n      : { rejectUnauthorized: false },\n});\n\nconst adapter = new PrismaPg(pool);\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    adapter,\n    log: logLevels,\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA;AACA;AACA;;;;;;;;;;AAEA,oEAAoE;AACpE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,kBAAkB,KAAK;AAC1D,MAAM,YACJ,uCACI,iBACE;IAAC;IAAS;IAAS;CAAO,GAC1B;IAAC;IAAS;CAAO,GACnB;AAEN,kDAAkD;AAClD,MAAM,kBAAkB;AAIxB,oEAAoE;AACpE,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,mHAAG,CAAC,KAAK;IAC3B,KACE,sCACI,0BACA;QAAE,oBAAoB;IAAM;AACpC;AAEA,MAAM,UAAU,IAAI,8JAAQ,CAAC;AAEtB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf;IACA,KAAK;AACP;AAEF,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/supabaseServer.ts"],"sourcesContent":["import \"server-only\";\nimport { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\nimport { env } from \"@/lib/env\";\n\nfunction decodeBase64Cookie(raw: string) {\n  const BASE64_PREFIX = \"base64-\";\n  if (!raw.startsWith(BASE64_PREFIX)) return raw;\n\n  const base = raw.slice(BASE64_PREFIX.length);\n  const encodings: BufferEncoding[] = [\"base64url\", \"base64\"];\n\n  for (const enc of encodings) {\n    try {\n      return Buffer.from(base, enc).toString(\"utf-8\");\n    } catch {\n      /* try next */\n    }\n  }\n\n  // Se não conseguirmos decodificar, tratamos como cookie ausente para evitar JSON.parse de strings inválidas\n  return undefined;\n}\n\n/**\n * Server-side Supabase client (SSR + Route Handlers)\n * - Safe cookie reading\n * - Safe cookie writing\n * - Prevents JSON parse errors\n * - No profile fetching here\n */\nexport async function createSupabaseServer() {\n  const cookieStore = (await cookies());\n\n  const supabase = createServerClient(\n    env.supabaseUrl,\n    env.supabaseAnonKey,\n    {\n      cookies: {\n        get(name: string) {\n          try {\n            // Só devolvemos cookies do Supabase (sb-*) e ignoramos o resto\n            if (!name.startsWith(\"sb-\")) return undefined;\n            const raw = cookieStore.get(name)?.value;\n            if (!raw) return undefined;\n\n            // Se for um chunk (sb-*.0, sb-*.1, ...), deixamos intacto para o combinador do Supabase tratar\n            const isChunk = /\\.\\d+$/.test(name);\n            return isChunk ? raw : decodeBase64Cookie(raw);\n          } catch {\n            return undefined;\n          }\n        },\n        set(name: string, value: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value, ...options });\n          } catch {\n            /* ignore errors for RSC */\n          }\n        },\n        remove(name: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value: \"\", ...options, maxAge: 0 });\n          } catch {\n            /* ignore */\n          }\n        },\n      },\n    }\n  );\n\n  return supabase;\n}\n\n\nexport async function getCurrentUser() {\n  const supabase = await createSupabaseServer();\n\n  try {\n    const { data, error } = await supabase.auth.getUser();\n\n    if (error || !data?.user) {\n      return { user: null, error };\n    }\n\n    return { user: data.user, error: null };\n  } catch (err) {\n    return { user: null, error: err };\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAEA,SAAS,mBAAmB,GAAW;IACrC,MAAM,gBAAgB;IACtB,IAAI,CAAC,IAAI,UAAU,CAAC,gBAAgB,OAAO;IAE3C,MAAM,OAAO,IAAI,KAAK,CAAC,cAAc,MAAM;IAC3C,MAAM,YAA8B;QAAC;QAAa;KAAS;IAE3D,KAAK,MAAM,OAAO,UAAW;QAC3B,IAAI;YACF,OAAO,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,CAAC;QACzC,EAAE,OAAM;QACN,YAAY,GACd;IACF;IAEA,4GAA4G;IAC5G,OAAO;AACT;AASO,eAAe;IACpB,MAAM,cAAe,MAAM,IAAA,4IAAO;IAElC,MAAM,WAAW,IAAA,iMAAkB,EACjC,mHAAG,CAAC,WAAW,EACf,mHAAG,CAAC,eAAe,EACnB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,IAAI;oBACF,+DAA+D;oBAC/D,IAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,OAAO;oBACpC,MAAM,MAAM,YAAY,GAAG,CAAC,OAAO;oBACnC,IAAI,CAAC,KAAK,OAAO;oBAEjB,+FAA+F;oBAC/F,MAAM,UAAU,SAAS,IAAI,CAAC;oBAC9B,OAAO,UAAU,MAAM,mBAAmB;gBAC5C,EAAE,OAAM;oBACN,OAAO;gBACT;YACF;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAgC;gBAC/D,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM;wBAAO,GAAG,OAAO;oBAAC;gBAC5C,EAAE,OAAM;gBACN,yBAAyB,GAC3B;YACF;YACA,QAAO,IAAY,EAAE,OAAgC;gBACnD,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM,OAAO;wBAAI,GAAG,OAAO;wBAAE,QAAQ;oBAAE;gBAC3D,EAAE,OAAM;gBACN,UAAU,GACZ;YACF;QACF;IACF;IAGF,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,WAAW,MAAM;IAEvB,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAEnD,IAAI,SAAS,CAAC,MAAM,MAAM;YACxB,OAAO;gBAAE,MAAM;gBAAM;YAAM;QAC7B;QAEA,OAAO;YAAE,MAAM,KAAK,IAAI;YAAE,OAAO;QAAK;IACxC,EAAE,OAAO,KAAK;QACZ,OAAO;YAAE,MAAM;YAAM,OAAO;QAAI;IAClC;AACF"}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/organizerRoles.ts"],"sourcesContent":["import { OrganizerMemberRole, Prisma, PrismaClient } from \"@prisma/client\";\nimport { prisma } from \"@/lib/prisma\";\n\ntype TxLike = Prisma.TransactionClient | PrismaClient;\n\n/**\n * Garante unicidade de OWNER numa organização:\n * - promove/cria o utilizador como OWNER\n * - despromove todos os outros OWNER para CO_OWNER\n */\nexport async function setSoleOwner(\n  client: TxLike,\n  organizerId: number,\n  userId: string,\n  invitedByUserId?: string | null,\n) {\n  await client.organizerMember.upsert({\n    where: { organizerId_userId: { organizerId, userId } },\n    update: { role: OrganizerMemberRole.OWNER },\n    create: {\n      organizerId,\n      userId,\n      role: OrganizerMemberRole.OWNER,\n      invitedByUserId: invitedByUserId ?? undefined,\n    },\n  });\n\n  await client.organizerMember.updateMany({\n    where: { organizerId, role: OrganizerMemberRole.OWNER, userId: { not: userId } },\n    data: { role: OrganizerMemberRole.CO_OWNER },\n  });\n}\n\n/**\n * Marca o perfil como \"organizer\" no array de roles (idempotente).\n */\nexport async function ensureUserIsOrganizer(client: TxLike, userId: string) {\n  const targetProfile = await client.profile.findUnique({\n    where: { id: userId },\n    select: { roles: true },\n  });\n  if (!targetProfile) return;\n\n  const roles = Array.isArray(targetProfile.roles) ? targetProfile.roles : [];\n  if (!roles.includes(\"organizer\")) {\n    await client.profile.update({\n      where: { id: userId },\n      data: { roles: [...roles, \"organizer\"] },\n    });\n  }\n}\n\n/**\n * Wrapper que permite usar helper fora de transação quando necessário.\n */\nexport async function setSoleOwnerSafe(\n  organizerId: number,\n  userId: string,\n  invitedByUserId?: string | null,\n) {\n  return setSoleOwner(prisma, organizerId, userId, invitedByUserId);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;;;;;AASO,eAAe,aACpB,MAAc,EACd,WAAmB,EACnB,MAAc,EACd,eAA+B;IAE/B,MAAM,OAAO,eAAe,CAAC,MAAM,CAAC;QAClC,OAAO;YAAE,oBAAoB;gBAAE;gBAAa;YAAO;QAAE;QACrD,QAAQ;YAAE,MAAM,oJAAmB,CAAC,KAAK;QAAC;QAC1C,QAAQ;YACN;YACA;YACA,MAAM,oJAAmB,CAAC,KAAK;YAC/B,iBAAiB,mBAAmB;QACtC;IACF;IAEA,MAAM,OAAO,eAAe,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE;YAAa,MAAM,oJAAmB,CAAC,KAAK;YAAE,QAAQ;gBAAE,KAAK;YAAO;QAAE;QAC/E,MAAM;YAAE,MAAM,oJAAmB,CAAC,QAAQ;QAAC;IAC7C;AACF;AAKO,eAAe,sBAAsB,MAAc,EAAE,MAAc;IACxE,MAAM,gBAAgB,MAAM,OAAO,OAAO,CAAC,UAAU,CAAC;QACpD,OAAO;YAAE,IAAI;QAAO;QACpB,QAAQ;YAAE,OAAO;QAAK;IACxB;IACA,IAAI,CAAC,eAAe;IAEpB,MAAM,QAAQ,MAAM,OAAO,CAAC,cAAc,KAAK,IAAI,cAAc,KAAK,GAAG,EAAE;IAC3E,IAAI,CAAC,MAAM,QAAQ,CAAC,cAAc;QAChC,MAAM,OAAO,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBAAE,OAAO;uBAAI;oBAAO;iBAAY;YAAC;QACzC;IACF;AACF;AAKO,eAAe,iBACpB,WAAmB,EACnB,MAAc,EACd,eAA+B;IAE/B,OAAO,aAAa,yHAAM,EAAE,aAAa,QAAQ;AACnD"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/organizerId.ts"],"sourcesContent":["import { cookies } from \"next/headers\";\nimport type { NextRequest } from \"next/server\";\n\nexport const ORGANIZER_COOKIE_NAME = \"orya_org\";\n\nexport function parseOrganizerId(value: unknown): number | null {\n  if (typeof value === \"number\") {\n    return Number.isFinite(value) && value > 0 ? value : null;\n  }\n  if (typeof value !== \"string\") return null;\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  const parsed = Number(trimmed);\n  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;\n}\n\nexport async function resolveOrganizerIdFromCookies(): Promise<number | null> {\n  try {\n    const cookieStore = await cookies();\n    return parseOrganizerId(cookieStore.get(ORGANIZER_COOKIE_NAME)?.value);\n  } catch {\n    return null;\n  }\n}\n\nexport function resolveOrganizerIdFromRequest(req: NextRequest): number | null {\n  const params = req.nextUrl.searchParams;\n  const paramValue = params.get(\"organizerId\") ?? params.get(\"org\");\n  return parseOrganizerId(paramValue) ?? parseOrganizerId(req.cookies.get(ORGANIZER_COOKIE_NAME)?.value);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAGO,MAAM,wBAAwB;AAE9B,SAAS,iBAAiB,KAAc;IAC7C,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO,OAAO,QAAQ,CAAC,UAAU,QAAQ,IAAI,QAAQ;IACvD;IACA,IAAI,OAAO,UAAU,UAAU,OAAO;IACtC,MAAM,UAAU,MAAM,IAAI;IAC1B,IAAI,CAAC,SAAS,OAAO;IACrB,MAAM,SAAS,OAAO;IACtB,OAAO,OAAO,QAAQ,CAAC,WAAW,SAAS,IAAI,SAAS;AAC1D;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,OAAO,iBAAiB,YAAY,GAAG,CAAC,wBAAwB;IAClE,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,8BAA8B,GAAgB;IAC5D,MAAM,SAAS,IAAI,OAAO,CAAC,YAAY;IACvC,MAAM,aAAa,OAAO,GAAG,CAAC,kBAAkB,OAAO,GAAG,CAAC;IAC3D,OAAO,iBAAiB,eAAe,iBAAiB,IAAI,OAAO,CAAC,GAAG,CAAC,wBAAwB;AAClG"}},
    {"offset": {"line": 429, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/organizerContext.ts"],"sourcesContent":["import { OrganizerMemberRole } from \"@prisma/client\";\nimport { prisma } from \"@/lib/prisma\";\nimport { ensureUserIsOrganizer } from \"@/lib/organizerRoles\";\nimport { resolveOrganizerIdFromCookies } from \"@/lib/organizerId\";\n\ntype Options = {\n  organizerId?: number | null;\n  roles?: OrganizerMemberRole[];\n  // Se quisermos forçar leitura de cookie, basta passar organizerId externamente\n};\n\nexport async function ensureLegacyOrganizerMemberships(userId: string, organizerId?: number | null) {\n  if (!userId) return 0;\n\n  const legacyOrganizers = await prisma.organizer.findMany({\n    where: {\n      userId,\n      ...(Number.isFinite(organizerId) ? { id: organizerId! } : {}),\n    },\n    select: { id: true },\n  });\n\n  if (legacyOrganizers.length === 0) return 0;\n\n  try {\n    await prisma.$transaction(async (tx) => {\n      for (const organizer of legacyOrganizers) {\n        await tx.organizerMember.upsert({\n          where: {\n            organizerId_userId: {\n              organizerId: organizer.id,\n              userId,\n            },\n          },\n          update: { role: OrganizerMemberRole.OWNER },\n          create: {\n            organizerId: organizer.id,\n            userId,\n            role: OrganizerMemberRole.OWNER,\n          },\n        });\n      }\n\n      await ensureUserIsOrganizer(tx, userId);\n    });\n  } catch (err: unknown) {\n    const msg =\n      typeof err === \"object\" && err && \"message\" in err ? String((err as { message?: unknown }).message) : \"\";\n    if (msg.includes(\"does not exist\") || msg.includes(\"organizer_members\")) {\n      return 0;\n    }\n    throw err;\n  }\n\n  return legacyOrganizers.length;\n}\n\nexport async function getActiveOrganizerForUser(userId: string, opts: Options = {}) {\n  const { roles } = opts;\n  const directOrganizerId =\n    typeof opts.organizerId === \"number\" && Number.isFinite(opts.organizerId)\n      ? opts.organizerId\n      : null;\n  const cookieOrganizerId = directOrganizerId ? null : await resolveOrganizerIdFromCookies();\n  const organizerId = directOrganizerId ?? cookieOrganizerId;\n\n  // 1) Se organizerId foi especificado, tenta buscar diretamente essa membership primeiro\n  if (organizerId) {\n    const direct = await prisma.organizerMember.findFirst({\n      where: {\n        userId,\n        organizerId,\n        ...(roles ? { role: { in: roles } } : {}),\n        organizer: { status: \"ACTIVE\" },\n      },\n      include: { organizer: true },\n    });\n    if (direct?.organizer) {\n      return { organizer: direct.organizer, membership: direct };\n    }\n\n    const legacyFixed = await ensureLegacyOrganizerMemberships(userId, organizerId);\n    if (legacyFixed > 0) {\n      const retry = await prisma.organizerMember.findFirst({\n        where: {\n          userId,\n          organizerId,\n          ...(roles ? { role: { in: roles } } : {}),\n          organizer: { status: \"ACTIVE\" },\n        },\n        include: { organizer: true },\n      });\n      if (retry?.organizer) {\n        return { organizer: retry.organizer, membership: retry };\n      }\n    }\n    // Se o organizerId foi pedido explicitamente e não existe membership, não faz fallback.\n    return { organizer: null, membership: null };\n  }\n\n  let memberships = await prisma.organizerMember.findMany({\n    where: {\n      userId,\n      ...(roles ? { role: { in: roles } } : {}),\n      organizer: { status: \"ACTIVE\" },\n    },\n    include: { organizer: true },\n    orderBy: [{ lastUsedAt: \"desc\" }, { createdAt: \"asc\" }],\n  });\n\n  if (memberships.length === 0) {\n    const legacyFixed = await ensureLegacyOrganizerMemberships(userId);\n    if (legacyFixed > 0) {\n      memberships = await prisma.organizerMember.findMany({\n        where: {\n          userId,\n          ...(roles ? { role: { in: roles } } : {}),\n          organizer: { status: \"ACTIVE\" },\n        },\n        include: { organizer: true },\n        orderBy: [{ lastUsedAt: \"desc\" }, { createdAt: \"asc\" }],\n      });\n    }\n  }\n\n  if (memberships && memberships.length > 0) {\n    if (memberships.length > 1) {\n      return { organizer: null, membership: null };\n    }\n    const selected = memberships[0];\n    if (selected?.organizer) {\n      return { organizer: selected.organizer, membership: selected };\n    }\n  }\n\n  return { organizer: null, membership: null };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/padel/validation.ts"],"sourcesContent":["export type PadelTieBreakRule =\n  | \"HEAD_TO_HEAD\"\n  | \"SET_DIFFERENCE\"\n  | \"GAME_DIFFERENCE\"\n  | \"POINTS\"\n  | \"COIN_TOSS\";\n\nexport type PadelPointsTable = Record<string, number>;\n\nexport type PadelScore = {\n  sets?: Array<{ teamA: number; teamB: number }>;\n  notes?: string;\n};\n\nexport function isValidTieBreakRules(value: unknown): value is PadelTieBreakRule[] {\n  if (!Array.isArray(value)) return false;\n  return value.every((item) =>\n    [\n      \"HEAD_TO_HEAD\",\n      \"SET_DIFFERENCE\",\n      \"GAME_DIFFERENCE\",\n      \"POINTS\",\n      \"COIN_TOSS\",\n    ].includes(String(item)),\n  );\n}\n\nexport function isValidPointsTable(value: unknown): value is PadelPointsTable {\n  if (!value || typeof value !== \"object\") return false;\n  return Object.values(value).every((v) => typeof v === \"number\" && Number.isFinite(v));\n}\n\nexport function isValidScore(value: unknown): value is PadelScore {\n  if (!value || typeof value !== \"object\") return false;\n  const obj = value as { sets?: unknown; notes?: unknown };\n  if (obj.sets) {\n    if (!Array.isArray(obj.sets)) return false;\n    const okSets = obj.sets.every(\n      (s) =>\n        s &&\n        typeof s === \"object\" &&\n        Number.isFinite((s as { teamA?: unknown }).teamA) &&\n        Number.isFinite((s as { teamB?: unknown }).teamB),\n    );\n    if (!okSets) return false;\n  }\n  if (obj.notes && typeof obj.notes !== \"string\") return false;\n  return true;\n}\n"],"names":[],"mappings":";;;;;;;;AAcO,SAAS,qBAAqB,KAAc;IACjD,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ,OAAO;IAClC,OAAO,MAAM,KAAK,CAAC,CAAC,OAClB;YACE;YACA;YACA;YACA;YACA;SACD,CAAC,QAAQ,CAAC,OAAO;AAEtB;AAEO,SAAS,mBAAmB,KAAc;IAC/C,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU,OAAO;IAChD,OAAO,OAAO,MAAM,CAAC,OAAO,KAAK,CAAC,CAAC,IAAM,OAAO,MAAM,YAAY,OAAO,QAAQ,CAAC;AACpF;AAEO,SAAS,aAAa,KAAc;IACzC,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU,OAAO;IAChD,MAAM,MAAM;IACZ,IAAI,IAAI,IAAI,EAAE;QACZ,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI,IAAI,GAAG,OAAO;QACrC,MAAM,SAAS,IAAI,IAAI,CAAC,KAAK,CAC3B,CAAC,IACC,KACA,OAAO,MAAM,YACb,OAAO,QAAQ,CAAC,AAAC,EAA0B,KAAK,KAChD,OAAO,QAAQ,CAAC,AAAC,EAA0B,KAAK;QAEpD,IAAI,CAAC,QAAQ,OAAO;IACtB;IACA,IAAI,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK,KAAK,UAAU,OAAO;IACvD,OAAO;AACT"}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/notifications/outbox.ts"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\nimport type { Prisma } from \"@prisma/client\";\n\nexport type OutboxStatus = \"PENDING\" | \"SENT\" | \"FAILED\";\n\ntype EnqueueParams = {\n  dedupeKey: string;\n  userId?: string | null;\n  notificationType: string;\n  templateVersion?: string | null;\n  payload?: Prisma.JsonValue;\n  force?: boolean;\n};\n\n/**\n * Enqueue a notification with dedupe guarantees.\n * If the dedupeKey already exists, it returns the existing record unless force=true,\n * in which case it resets status to PENDING and updates payload/templateVersion.\n */\nexport async function enqueueNotification(params: EnqueueParams) {\n  const {\n    dedupeKey,\n    userId,\n    notificationType,\n    templateVersion,\n    payload = {},\n    force = false,\n  } = params;\n\n  const existing = await prisma.notificationOutbox.findUnique({\n    where: { dedupeKey },\n  });\n  if (existing && !force) {\n    return existing;\n  }\n\n  return prisma.notificationOutbox.upsert({\n    where: { dedupeKey },\n    create: {\n      dedupeKey,\n      userId: userId ?? null,\n      notificationType,\n      templateVersion: templateVersion ?? null,\n      payload,\n      status: \"PENDING\",\n    },\n    update: {\n      userId: userId ?? null,\n      notificationType,\n      templateVersion: templateVersion ?? null,\n      payload,\n      status: \"PENDING\",\n      retries: 0,\n      lastError: null,\n      sentAt: null,\n    },\n  });\n}\n\nexport async function markOutboxSent(id: string) {\n  return prisma.notificationOutbox.update({\n    where: { id },\n    data: { status: \"SENT\", sentAt: new Date(), lastError: null },\n  });\n}\n\nexport async function markOutboxFailed(id: string, error: string) {\n  return prisma.notificationOutbox.update({\n    where: { id },\n    data: { status: \"FAILED\", lastError: error, retries: { increment: 1 } },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;AAmBO,eAAe,oBAAoB,MAAqB;IAC7D,MAAM,EACJ,SAAS,EACT,MAAM,EACN,gBAAgB,EAChB,eAAe,EACf,UAAU,CAAC,CAAC,EACZ,QAAQ,KAAK,EACd,GAAG;IAEJ,MAAM,WAAW,MAAM,yHAAM,CAAC,kBAAkB,CAAC,UAAU,CAAC;QAC1D,OAAO;YAAE;QAAU;IACrB;IACA,IAAI,YAAY,CAAC,OAAO;QACtB,OAAO;IACT;IAEA,OAAO,yHAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC;QACtC,OAAO;YAAE;QAAU;QACnB,QAAQ;YACN;YACA,QAAQ,UAAU;YAClB;YACA,iBAAiB,mBAAmB;YACpC;YACA,QAAQ;QACV;QACA,QAAQ;YACN,QAAQ,UAAU;YAClB;YACA,iBAAiB,mBAAmB;YACpC;YACA,QAAQ;YACR,SAAS;YACT,WAAW;YACX,QAAQ;QACV;IACF;AACF;AAEO,eAAe,eAAe,EAAU;IAC7C,OAAO,yHAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC;QACtC,OAAO;YAAE;QAAG;QACZ,MAAM;YAAE,QAAQ;YAAQ,QAAQ,IAAI;YAAQ,WAAW;QAAK;IAC9D;AACF;AAEO,eAAe,iBAAiB,EAAU,EAAE,KAAa;IAC9D,OAAO,yHAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC;QACtC,OAAO;YAAE;QAAG;QACZ,MAAM;YAAE,QAAQ;YAAU,WAAW;YAAO,SAAS;gBAAE,WAAW;YAAE;QAAE;IACxE;AACF"}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/notifications/producer.ts"],"sourcesContent":["import { enqueueNotification } from \"@/domain/notifications/outbox\";\nimport type { NotificationTemplate } from \"@/domain/notifications/types\";\n\ntype CommonArgs = {\n  userId: string;\n  templateVersion?: string;\n  payload?: Record<string, unknown>;\n};\n\nfunction buildDedupe(prefix: string, parts: Array<string | number | null | undefined>) {\n  return [prefix, ...parts.map((p) => (p === null || p === undefined ? \"null\" : String(p)))].join(\":\");\n}\n\nasync function queue(\n  type: NotificationTemplate,\n  dedupeKey: string,\n  args: CommonArgs & { force?: boolean },\n) {\n  return enqueueNotification({\n    dedupeKey,\n    notificationType: type,\n    templateVersion: args.templateVersion ?? \"v1\",\n    userId: args.userId,\n    payload: args.payload ?? {},\n    force: args.force ?? false,\n  });\n}\n\nexport async function notifyPairingInvite(params: {\n  pairingId: number;\n  tournamentId?: number;\n  targetUserId: string;\n  inviterUserId?: string;\n  token?: string;\n}) {\n  const dedupeKey = buildDedupe(\"PAIRING_INVITE\", [params.pairingId, params.targetUserId]);\n  return queue(\"PAIRING_INVITE\", dedupeKey, {\n    userId: params.targetUserId,\n    payload: {\n      pairingId: params.pairingId,\n      tournamentId: params.tournamentId,\n      inviterUserId: params.inviterUserId,\n      token: params.token,\n    },\n  });\n}\n\nexport async function notifyPairingReminder(params: { pairingId: number; targetUserId: string }) {\n  const dedupeKey = buildDedupe(\"PAIRING_REMINDER\", [params.pairingId, params.targetUserId]);\n  return queue(\"PAIRING_REMINDER\", dedupeKey, {\n    userId: params.targetUserId,\n    payload: { pairingId: params.pairingId },\n    templateVersion: \"v1\",\n  });\n}\n\nexport async function notifyPartnerPaid(params: {\n  pairingId: number;\n  captainUserId: string;\n  partnerUserId?: string;\n}) {\n  const dedupeKey = buildDedupe(\"PARTNER_PAID\", [params.pairingId, params.captainUserId]);\n  return queue(\"PARTNER_PAID\", dedupeKey, {\n    userId: params.captainUserId,\n    payload: { pairingId: params.pairingId, partnerUserId: params.partnerUserId },\n  });\n}\n\nexport async function notifyDeadlineExpired(params: { pairingId: number; userId: string }) {\n  const dedupeKey = buildDedupe(\"DEADLINE_EXPIRED\", [params.pairingId, params.userId]);\n  return queue(\"DEADLINE_EXPIRED\", dedupeKey, {\n    userId: params.userId,\n    payload: { pairingId: params.pairingId },\n  });\n}\n\nexport async function notifyOffsessionActionRequired(params: { pairingId: number; userId: string }) {\n  const dedupeKey = buildDedupe(\"OFFSESSION_ACTION_REQUIRED\", [params.pairingId, params.userId]);\n  return queue(\"OFFSESSION_ACTION_REQUIRED\", dedupeKey, {\n    userId: params.userId,\n    payload: { pairingId: params.pairingId },\n  });\n}\n\nexport async function notifyNewFollower(params: { targetUserId: string; followerUserId: string }) {\n  const dedupeKey = buildDedupe(\"NEW_FOLLOWER\", [params.targetUserId, params.followerUserId]);\n  return queue(\"NEW_FOLLOWER\", dedupeKey, {\n    userId: params.targetUserId,\n    payload: { followerUserId: params.followerUserId },\n  });\n}\n\nexport async function notifyPairingRequestReceived(params: { targetUserId: string; pairingId: number }) {\n  const dedupeKey = buildDedupe(\"PAIRING_REQUEST_RECEIVED\", [params.pairingId, params.targetUserId]);\n  return queue(\"PAIRING_REQUEST_RECEIVED\", dedupeKey, {\n    userId: params.targetUserId,\n    payload: { pairingId: params.pairingId },\n  });\n}\n\nexport async function notifyPairingRequestAccepted(params: { targetUserId: string; pairingId: number }) {\n  const dedupeKey = buildDedupe(\"PAIRING_REQUEST_ACCEPTED\", [params.pairingId, params.targetUserId]);\n  return queue(\"PAIRING_REQUEST_ACCEPTED\", dedupeKey, {\n    userId: params.targetUserId,\n    payload: { pairingId: params.pairingId },\n  });\n}\n\nexport async function notifyTicketWaitingClaim(params: { userId: string; ticketId: string }) {\n  const dedupeKey = buildDedupe(\"TICKET_WAITING_CLAIM\", [params.ticketId, params.userId]);\n  return queue(\"TICKET_WAITING_CLAIM\", dedupeKey, {\n    userId: params.userId,\n    payload: { ticketId: params.ticketId },\n  });\n}\n\nexport async function notifyBracketPublished(params: { userId: string; tournamentId: number }) {\n  const dedupeKey = buildDedupe(\"BRACKET_PUBLISHED\", [params.tournamentId, params.userId]);\n  return queue(\"BRACKET_PUBLISHED\", dedupeKey, {\n    userId: params.userId,\n    payload: { tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyTournamentEve(params: { userId: string; tournamentId: number }) {\n  const dedupeKey = buildDedupe(\"TOURNAMENT_EVE_REMINDER\", [params.tournamentId, params.userId]);\n  return queue(\"TOURNAMENT_EVE_REMINDER\", dedupeKey, {\n    userId: params.userId,\n    payload: { tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyMatchResult(params: { userId: string; matchId: number; tournamentId?: number }) {\n  const dedupeKey = buildDedupe(\"MATCH_RESULT\", [params.matchId, params.userId]);\n  return queue(\"MATCH_RESULT\", dedupeKey, {\n    userId: params.userId,\n    payload: { matchId: params.matchId, tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyNextOpponent(params: { userId: string; matchId: number; tournamentId?: number }) {\n  const dedupeKey = buildDedupe(\"NEXT_OPPONENT\", [params.matchId, params.userId]);\n  return queue(\"NEXT_OPPONENT\", dedupeKey, {\n    userId: params.userId,\n    payload: { matchId: params.matchId, tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyMatchChanged(params: {\n  userId: string;\n  matchId: number;\n  startAt?: Date | null;\n  courtId?: number | null;\n}) {\n  const dedupeKey = buildDedupe(\"MATCH_CHANGED\", [\n    params.matchId,\n    params.startAt ? params.startAt.toISOString() : null,\n    params.courtId ?? null,\n  ]);\n  return queue(\"MATCH_CHANGED\", dedupeKey, {\n    userId: params.userId,\n    payload: { matchId: params.matchId, startAt: params.startAt ?? null, courtId: params.courtId ?? null },\n  });\n}\n\nexport async function notifyEliminated(params: { userId: string; tournamentId: number }) {\n  const dedupeKey = buildDedupe(\"ELIMINATED\", [params.tournamentId, params.userId]);\n  return queue(\"ELIMINATED\", dedupeKey, {\n    userId: params.userId,\n    payload: { tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyChampion(params: { userId: string; tournamentId: number }) {\n  const dedupeKey = buildDedupe(\"CHAMPION\", [params.tournamentId, params.userId]);\n  return queue(\"CHAMPION\", dedupeKey, {\n    userId: params.userId,\n    payload: { tournamentId: params.tournamentId },\n  });\n}\n\nexport async function notifyBroadcast(params: {\n  tournamentId: number;\n  userId: string;\n  broadcastId: string;\n  audienceKey: string;\n}) {\n  const dedupeKey = buildDedupe(\"BROADCAST\", [params.tournamentId, params.audienceKey, params.userId]);\n  return queue(\"BROADCAST\", dedupeKey, {\n    userId: params.userId,\n    payload: { tournamentId: params.tournamentId, broadcastId: params.broadcastId },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/notifications/matchChangeDedupe.ts"],"sourcesContent":["import crypto from \"crypto\";\n\nexport function computeDedupeKey(matchId: number, startAt: Date | null, courtId: number | null) {\n  const payload = `${matchId}|${startAt ? startAt.toISOString() : \"null\"}|${courtId ?? \"null\"}`;\n  return crypto.createHash(\"sha256\").update(payload).digest(\"hex\");\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,iBAAiB,OAAe,EAAE,OAAoB,EAAE,OAAsB;IAC5F,MAAM,UAAU,GAAG,QAAQ,CAAC,EAAE,UAAU,QAAQ,WAAW,KAAK,OAAO,CAAC,EAAE,WAAW,QAAQ;IAC7F,OAAO,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,SAAS,MAAM,CAAC;AAC5D"}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/notifications/tournament.ts"],"sourcesContent":["import {\n  notifyBracketPublished,\n  notifyChampion,\n  notifyEliminated,\n  notifyMatchChanged,\n  notifyMatchResult,\n  notifyNextOpponent,\n  notifyTournamentEve,\n  notifyBroadcast,\n} from \"@/domain/notifications/producer\";\nimport { computeDedupeKey as dedupeMatchChange } from \"@/domain/notifications/matchChangeDedupe\";\n\nexport async function queueBracketPublished(userIds: string[], tournamentId: number) {\n  await Promise.all(userIds.map((userId) => notifyBracketPublished({ userId, tournamentId })));\n}\n\nexport async function queueTournamentEve(userIds: string[], tournamentId: number) {\n  await Promise.all(userIds.map((userId) => notifyTournamentEve({ userId, tournamentId })));\n}\n\nexport async function queueMatchResult(userIds: string[], matchId: number, tournamentId?: number) {\n  await Promise.all(userIds.map((userId) => notifyMatchResult({ userId, matchId, tournamentId })));\n}\n\nexport async function queueNextOpponent(userIds: string[], matchId: number, tournamentId?: number) {\n  await Promise.all(userIds.map((userId) => notifyNextOpponent({ userId, matchId, tournamentId })));\n}\n\nexport async function queueMatchChanged(params: {\n  userIds: string[];\n  matchId: number;\n  startAt?: Date | null;\n  courtId?: number | null;\n}) {\n  const { userIds, matchId, startAt = null, courtId = null } = params;\n  // Use the same dedupe hash as scheduling dedupe so we never send twice for identical change.\n  const dedupeKey = dedupeMatchChange(matchId, startAt, courtId);\n  await Promise.all(\n    userIds.map((userId) =>\n      notifyMatchChanged({\n        userId,\n        matchId,\n        startAt,\n        courtId,\n        // force so the shared dedupeKey applies across recipients\n      }),\n    ),\n  );\n  return dedupeKey;\n}\n\nexport async function queueEliminated(userIds: string[], tournamentId: number) {\n  await Promise.all(userIds.map((userId) => notifyEliminated({ userId, tournamentId })));\n}\n\nexport async function queueChampion(userIds: string[], tournamentId: number) {\n  await Promise.all(userIds.map((userId) => notifyChampion({ userId, tournamentId })));\n}\n\nexport async function queueBroadcast(params: {\n  audienceUserIds: string[];\n  tournamentId: number;\n  broadcastId: string;\n  audienceKey: string;\n}) {\n  const { audienceUserIds, tournamentId, broadcastId, audienceKey } = params;\n  await Promise.all(\n    audienceUserIds.map((userId) =>\n      notifyBroadcast({ userId, tournamentId, broadcastId, audienceKey }),\n    ),\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAUA;;;;;;;AAEO,eAAe,sBAAsB,OAAiB,EAAE,YAAoB;IACjF,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,+JAAsB,EAAC;YAAE;YAAQ;QAAa;AAC1F;AAEO,eAAe,mBAAmB,OAAiB,EAAE,YAAoB;IAC9E,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,4JAAmB,EAAC;YAAE;YAAQ;QAAa;AACvF;AAEO,eAAe,iBAAiB,OAAiB,EAAE,OAAe,EAAE,YAAqB;IAC9F,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,0JAAiB,EAAC;YAAE;YAAQ;YAAS;QAAa;AAC9F;AAEO,eAAe,kBAAkB,OAAiB,EAAE,OAAe,EAAE,YAAqB;IAC/F,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,2JAAkB,EAAC;YAAE;YAAQ;YAAS;QAAa;AAC/F;AAEO,eAAe,kBAAkB,MAKvC;IACC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,IAAI,EAAE,UAAU,IAAI,EAAE,GAAG;IAC7D,6FAA6F;IAC7F,MAAM,YAAY,IAAA,kKAAiB,EAAC,SAAS,SAAS;IACtD,MAAM,QAAQ,GAAG,CACf,QAAQ,GAAG,CAAC,CAAC,SACX,IAAA,2JAAkB,EAAC;YACjB;YACA;YACA;YACA;QAEF;IAGJ,OAAO;AACT;AAEO,eAAe,gBAAgB,OAAiB,EAAE,YAAoB;IAC3E,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,yJAAgB,EAAC;YAAE;YAAQ;QAAa;AACpF;AAEO,eAAe,cAAc,OAAiB,EAAE,YAAoB;IACzE,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,IAAA,uJAAc,EAAC;YAAE;YAAQ;QAAa;AAClF;AAEO,eAAe,eAAe,MAKpC;IACC,MAAM,EAAE,eAAe,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG;IACpE,MAAM,QAAQ,GAAG,CACf,gBAAgB,GAAG,CAAC,CAAC,SACnB,IAAA,wJAAe,EAAC;YAAE;YAAQ;YAAc;YAAa;QAAY;AAGvE"}},
    {"offset": {"line": 1146, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/padel/staff.ts"],"sourcesContent":["\"use server\";\n\nimport { StaffRole, StaffScope, StaffStatus } from \"@prisma/client\";\nimport { prisma } from \"@/lib/prisma\";\n\n/**\n * Verifica se o utilizador tem permissão de staff (GLOBAL ou EVENT) para gerir padel no organizer.\n */\nexport async function isPadelStaff(userId: string, organizerId: number, eventId?: number | null) {\n  if (!userId || !organizerId) return false;\n  const scopeFilter =\n    typeof eventId === \"number\"\n      ? { OR: [{ scope: StaffScope.GLOBAL }, { scope: StaffScope.EVENT, eventId }] }\n      : { scope: StaffScope.GLOBAL };\n  const assignment = await prisma.staffAssignment.findFirst({\n    where: {\n      userId,\n      organizerId,\n      status: StaffStatus.ACCEPTED,\n      revokedAt: null,\n      role: { in: [StaffRole.OWNER, StaffRole.ADMIN, StaffRole.STAFF, StaffRole.CHECKIN] },\n      ...scopeFilter,\n    },\n    select: { id: true },\n  });\n  return Boolean(assignment);\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;;;;;AAKO,eAAe,aAAa,MAAc,EAAE,WAAmB,EAAE,OAAuB;IAC7F,IAAI,CAAC,UAAU,CAAC,aAAa,OAAO;IACpC,MAAM,cACJ,OAAO,YAAY,WACf;QAAE,IAAI;YAAC;gBAAE,OAAO,2IAAU,CAAC,MAAM;YAAC;YAAG;gBAAE,OAAO,2IAAU,CAAC,KAAK;gBAAE;YAAQ;SAAE;IAAC,IAC3E;QAAE,OAAO,2IAAU,CAAC,MAAM;IAAC;IACjC,MAAM,aAAa,MAAM,yHAAM,CAAC,eAAe,CAAC,SAAS,CAAC;QACxD,OAAO;YACL;YACA;YACA,QAAQ,4IAAW,CAAC,QAAQ;YAC5B,WAAW;YACX,MAAM;gBAAE,IAAI;oBAAC,0IAAS,CAAC,KAAK;oBAAE,0IAAS,CAAC,KAAK;oBAAE,0IAAS,CAAC,KAAK;oBAAE,0IAAS,CAAC,OAAO;iBAAC;YAAC;YACnF,GAAG,WAAW;QAChB;QACA,QAAQ;YAAE,IAAI;QAAK;IACrB;IACA,OAAO,QAAQ;AACjB;;;IAlBsB;;AAAA,iPAAA"}},
    {"offset": {"line": 1210, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/app/api/padel/matches/route.ts"],"sourcesContent":["export const runtime = \"nodejs\";\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { OrganizerMemberRole, PadelMatchStatus } from \"@prisma/client\";\nimport { prisma } from \"@/lib/prisma\";\nimport { createSupabaseServer } from \"@/lib/supabaseServer\";\nimport { getActiveOrganizerForUser } from \"@/lib/organizerContext\";\nimport { isValidScore } from \"@/lib/padel/validation\";\nimport {\n  queueMatchChanged,\n  queueMatchResult,\n  queueNextOpponent,\n} from \"@/domain/notifications/tournament\";\nimport { isPadelStaff } from \"@/lib/padel/staff\";\n\nconst allowedRoles: OrganizerMemberRole[] = [\"OWNER\", \"CO_OWNER\", \"ADMIN\"];\n\nfunction sortRoundsBySize(matches: Array<{ roundLabel: string | null }>) {\n  const counts = matches.reduce<Record<string, number>>((acc, m) => {\n    const key = m.roundLabel || \"?\";\n    acc[key] = (acc[key] || 0) + 1;\n    return acc;\n  }, {});\n  return Object.entries(counts).sort((a, b) => b[1] - a[1]);\n}\n\nexport async function GET(req: NextRequest) {\n  const supabase = await createSupabaseServer();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) return NextResponse.json({ ok: false, error: \"UNAUTHENTICATED\" }, { status: 401 });\n\n  const eventId = Number(req.nextUrl.searchParams.get(\"eventId\"));\n  const categoryId = Number(req.nextUrl.searchParams.get(\"categoryId\"));\n  if (!Number.isFinite(eventId)) return NextResponse.json({ ok: false, error: \"INVALID_EVENT\" }, { status: 400 });\n  const matchCategoryFilter = Number.isFinite(categoryId) ? { categoryId } : {};\n\n  const event = await prisma.event.findUnique({\n    where: { id: eventId },\n    select: { organizerId: true },\n  });\n  if (!event?.organizerId) return NextResponse.json({ ok: false, error: \"EVENT_NOT_FOUND\" }, { status: 404 });\n  const { organizer } = await getActiveOrganizerForUser(user.id, {\n    organizerId: event.organizerId,\n    roles: allowedRoles,\n  });\n  const isStaff = await isPadelStaff(user.id, event.organizerId, eventId);\n  if (!organizer && !isStaff) return NextResponse.json({ ok: false, error: \"FORBIDDEN\" }, { status: 403 });\n\n  const matches = await prisma.padelMatch.findMany({\n    where: { eventId, ...matchCategoryFilter },\n    include: {\n      pairingA: { include: { slots: { include: { playerProfile: true } } } },\n      pairingB: { include: { slots: { include: { playerProfile: true } } } },\n    },\n    orderBy: [\n      { roundType: \"asc\" },\n      { groupLabel: \"asc\" },\n      { startTime: \"asc\" },\n      { id: \"asc\" },\n    ],\n  });\n\n  return NextResponse.json({ ok: true, items: matches }, { status: 200 });\n}\n\nexport async function POST(req: NextRequest) {\n  const supabase = await createSupabaseServer();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) return NextResponse.json({ ok: false, error: \"UNAUTHENTICATED\" }, { status: 401 });\n\n  const body = (await req.json().catch(() => null)) as Record<string, unknown> | null;\n  if (!body) return NextResponse.json({ ok: false, error: \"INVALID_BODY\" }, { status: 400 });\n\n  const matchId = typeof body.id === \"number\" ? body.id : Number(body.id);\n  const statusRaw = typeof body.status === \"string\" ? (body.status as PadelMatchStatus) : undefined;\n  const scoreRaw = body.score;\n  const startAtRaw = body.startAt ? new Date(String(body.startAt)) : undefined;\n  const courtIdRaw = typeof body.courtId === \"number\" ? body.courtId : undefined;\n\n  if (!Number.isFinite(matchId)) return NextResponse.json({ ok: false, error: \"INVALID_ID\" }, { status: 400 });\n  if (startAtRaw && Number.isNaN(startAtRaw.getTime())) {\n    return NextResponse.json({ ok: false, error: \"INVALID_START_AT\" }, { status: 400 });\n  }\n\n  const match = await prisma.padelMatch.findUnique({\n    where: { id: matchId },\n    include: { event: { select: { organizerId: true } } },\n  });\n  if (!match || !match.event?.organizerId) return NextResponse.json({ ok: false, error: \"MATCH_NOT_FOUND\" }, { status: 404 });\n\n  const { organizer, membership } = await getActiveOrganizerForUser(user.id, {\n    organizerId: match.event.organizerId,\n    roles: allowedRoles,\n  });\n  const isStaff = await isPadelStaff(user.id, match.event.organizerId, match.eventId);\n  if (!organizer && !isStaff) return NextResponse.json({ ok: false, error: \"NO_ORGANIZER\" }, { status: 403 });\n\n  if (scoreRaw && !isValidScore(scoreRaw)) {\n    return NextResponse.json({ ok: false, error: \"INVALID_SCORE\" }, { status: 400 });\n  }\n\n  let winnerPairingId: number | null = null;\n  if (scoreRaw && typeof scoreRaw === \"object\" && \"sets\" in (scoreRaw as { sets?: unknown })) {\n    const rawSets = (scoreRaw as { sets?: unknown }).sets;\n    const sets = Array.isArray(rawSets) ? rawSets : [];\n    let winsA = 0;\n    let winsB = 0;\n    sets.forEach((s) => {\n      const set = s as { teamA?: number; teamB?: number };\n      if (Number.isFinite(set.teamA) && Number.isFinite(set.teamB)) {\n        const a = Number(set.teamA);\n        const b = Number(set.teamB);\n        if (a > b) winsA += 1;\n        else if (b > a) winsB += 1;\n      }\n    });\n    if (winsA > winsB && match.pairingAId) winnerPairingId = match.pairingAId;\n    if (winsB > winsA && match.pairingBId) winnerPairingId = match.pairingBId;\n  }\n\n  const updated = await prisma.padelMatch.update({\n    where: { id: matchId },\n    data: {\n      status: statusRaw ?? match.status,\n      score: scoreRaw ?? match.score,\n      scoreSets: typeof scoreRaw === \"object\" && scoreRaw && \"sets\" in (scoreRaw as { sets?: unknown })\n        ? (scoreRaw as { sets?: unknown }).sets\n        : match.scoreSets,\n      winnerPairingId: winnerPairingId ?? match.winnerPairingId,\n      startTime: startAtRaw ?? match.startTime,\n      courtNumber: courtIdRaw ?? match.courtNumber,\n    },\n    include: {\n      pairingA: { include: { slots: { include: { playerProfile: true } } } },\n      pairingB: { include: { slots: { include: { playerProfile: true } } } },\n    },\n  });\n\n  const involvedUserIds = [\n    ...((updated.pairingA?.slots ?? []).map((s) => s.profileId).filter(Boolean) as string[]),\n    ...((updated.pairingB?.slots ?? []).map((s) => s.profileId).filter(Boolean) as string[]),\n  ];\n\n  // Notificações: mudança de horário/court\n  await queueMatchChanged({\n    userIds: involvedUserIds,\n    matchId: updated.id,\n    startAt: updated.startTime ?? null,\n    courtId: updated.courtNumber ?? null,\n  });\n\n  // Notificações de resultado + próximo adversário\n  if (winnerPairingId) {\n    await queueMatchResult(involvedUserIds, updated.id, updated.eventId);\n    await queueNextOpponent(involvedUserIds, updated.id, updated.eventId);\n\n    // Auto-avanço de vencedores no bracket (baseado em ordem dos jogos por ronda)\n    if (updated.roundType === \"KNOCKOUT\") {\n      const koMatches = await prisma.padelMatch.findMany({\n        where: {\n          eventId: updated.eventId,\n          roundType: \"KNOCKOUT\",\n          ...(updated.categoryId ? { categoryId: updated.categoryId } : {}),\n        },\n        select: { id: true, roundLabel: true, pairingAId: true, pairingBId: true, winnerPairingId: true },\n        orderBy: [{ roundLabel: \"asc\" }, { id: \"asc\" }],\n      });\n      const roundOrder = sortRoundsBySize(koMatches).map(([label]) => label);\n      const roundsMap = new Map<string, Array<typeof koMatches[number]>>();\n      roundOrder.forEach((label) => {\n        roundsMap.set(\n          label,\n          koMatches.filter((m) => (m.roundLabel || \"?\") === label),\n        );\n      });\n\n      const advance = async (fromMatchId: number, winner: number) => {\n        const fromMatch = koMatches.find((m) => m.id === fromMatchId);\n        if (!fromMatch) return;\n        const currentRound = fromMatch.roundLabel || roundOrder[0] || null;\n        const currentIdx = roundOrder.findIndex((l) => l === currentRound);\n        if (currentIdx === -1 || currentIdx >= roundOrder.length - 1) return;\n        const currentMatches = roundsMap.get(currentRound) || [];\n        const nextRoundLabel = roundOrder[currentIdx + 1];\n        const nextMatches = roundsMap.get(nextRoundLabel) || [];\n        const currentPos = currentMatches.findIndex((m) => m.id === fromMatchId);\n        if (currentPos === -1) return;\n        const targetIdx = Math.floor(currentPos / 2);\n        const target = nextMatches[targetIdx];\n        if (!target) return;\n        const updateTarget: Record<string, unknown> = {};\n        if (currentPos % 2 === 0) {\n          if (!target.pairingAId) updateTarget.pairingAId = winner;\n          else if (!target.pairingBId) updateTarget.pairingBId = winner;\n        } else {\n          if (!target.pairingBId) updateTarget.pairingBId = winner;\n          else if (!target.pairingAId) updateTarget.pairingAId = winner;\n        }\n        if (Object.keys(updateTarget).length > 0) {\n          const targetUpdated = await prisma.padelMatch.update({\n            where: { id: target.id },\n            data: updateTarget,\n          });\n          // atualizar caches locais\n          target.pairingAId = targetUpdated.pairingAId;\n          target.pairingBId = targetUpdated.pairingBId;\n          // BYE: auto-avançar\n          if (\n            (targetUpdated.pairingAId && !targetUpdated.pairingBId) ||\n            (!targetUpdated.pairingAId && targetUpdated.pairingBId)\n          ) {\n            const autoWinner = targetUpdated.pairingAId ?? targetUpdated.pairingBId!;\n            const autoDone = await prisma.padelMatch.update({\n              where: { id: targetUpdated.id },\n              data: { winnerPairingId: autoWinner, status: \"DONE\" },\n            });\n            target.winnerPairingId = autoDone.winnerPairingId;\n            target.pairingAId = autoDone.pairingAId;\n            target.pairingBId = autoDone.pairingBId;\n            await advance(target.id, autoWinner);\n          }\n        }\n      };\n\n      await advance(updated.id, winnerPairingId);\n    }\n  }\n\n  return NextResponse.json({ ok: true, match: updated }, { status: 200 });\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;AAbO,MAAM,UAAU;;;;;;;;AAevB,MAAM,eAAsC;IAAC;IAAS;IAAY;CAAQ;AAE1E,SAAS,iBAAiB,OAA6C;IACrE,MAAM,SAAS,QAAQ,MAAM,CAAyB,CAAC,KAAK;QAC1D,MAAM,MAAM,EAAE,UAAU,IAAI;QAC5B,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI;QAC7B,OAAO;IACT,GAAG,CAAC;IACJ,OAAO,OAAO,OAAO,CAAC,QAAQ,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC1D;AAEO,eAAe,IAAI,GAAgB;IACxC,MAAM,WAAW,MAAM,IAAA,+IAAoB;IAC3C,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,CAAC,MAAM,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAkB,GAAG;QAAE,QAAQ;IAAI;IAE3F,MAAM,UAAU,OAAO,IAAI,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;IACpD,MAAM,aAAa,OAAO,IAAI,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;IACvD,IAAI,CAAC,OAAO,QAAQ,CAAC,UAAU,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAgB,GAAG;QAAE,QAAQ;IAAI;IAC7G,MAAM,sBAAsB,OAAO,QAAQ,CAAC,cAAc;QAAE;IAAW,IAAI,CAAC;IAE5E,MAAM,QAAQ,MAAM,yHAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAC1C,OAAO;YAAE,IAAI;QAAQ;QACrB,QAAQ;YAAE,aAAa;QAAK;IAC9B;IACA,IAAI,CAAC,OAAO,aAAa,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAkB,GAAG;QAAE,QAAQ;IAAI;IACzG,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,sJAAyB,EAAC,KAAK,EAAE,EAAE;QAC7D,aAAa,MAAM,WAAW;QAC9B,OAAO;IACT;IACA,MAAM,UAAU,MAAM,IAAA,uIAAY,EAAC,KAAK,EAAE,EAAE,MAAM,WAAW,EAAE;IAC/D,IAAI,CAAC,aAAa,CAAC,SAAS,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAY,GAAG;QAAE,QAAQ;IAAI;IAEtG,MAAM,UAAU,MAAM,yHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;QAC/C,OAAO;YAAE;YAAS,GAAG,mBAAmB;QAAC;QACzC,SAAS;YACP,UAAU;gBAAE,SAAS;oBAAE,OAAO;wBAAE,SAAS;4BAAE,eAAe;wBAAK;oBAAE;gBAAE;YAAE;YACrE,UAAU;gBAAE,SAAS;oBAAE,OAAO;wBAAE,SAAS;4BAAE,eAAe;wBAAK;oBAAE;gBAAE;YAAE;QACvE;QACA,SAAS;YACP;gBAAE,WAAW;YAAM;YACnB;gBAAE,YAAY;YAAM;YACpB;gBAAE,WAAW;YAAM;YACnB;gBAAE,IAAI;YAAM;SACb;IACH;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAM,OAAO;IAAQ,GAAG;QAAE,QAAQ;IAAI;AACvE;AAEO,eAAe,KAAK,GAAgB;IACzC,MAAM,WAAW,MAAM,IAAA,+IAAoB;IAC3C,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,CAAC,MAAM,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAkB,GAAG;QAAE,QAAQ;IAAI;IAE3F,MAAM,OAAQ,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM;IAC3C,IAAI,CAAC,MAAM,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAe,GAAG;QAAE,QAAQ;IAAI;IAExF,MAAM,UAAU,OAAO,KAAK,EAAE,KAAK,WAAW,KAAK,EAAE,GAAG,OAAO,KAAK,EAAE;IACtE,MAAM,YAAY,OAAO,KAAK,MAAM,KAAK,WAAY,KAAK,MAAM,GAAwB;IACxF,MAAM,WAAW,KAAK,KAAK;IAC3B,MAAM,aAAa,KAAK,OAAO,GAAG,IAAI,KAAK,OAAO,KAAK,OAAO,KAAK;IACnE,MAAM,aAAa,OAAO,KAAK,OAAO,KAAK,WAAW,KAAK,OAAO,GAAG;IAErE,IAAI,CAAC,OAAO,QAAQ,CAAC,UAAU,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAa,GAAG;QAAE,QAAQ;IAAI;IAC1G,IAAI,cAAc,OAAO,KAAK,CAAC,WAAW,OAAO,KAAK;QACpD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAO,OAAO;QAAmB,GAAG;YAAE,QAAQ;QAAI;IACnF;IAEA,MAAM,QAAQ,MAAM,yHAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QAC/C,OAAO;YAAE,IAAI;QAAQ;QACrB,SAAS;YAAE,OAAO;gBAAE,QAAQ;oBAAE,aAAa;gBAAK;YAAE;QAAE;IACtD;IACA,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,EAAE,aAAa,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAkB,GAAG;QAAE,QAAQ;IAAI;IAEzH,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,MAAM,IAAA,sJAAyB,EAAC,KAAK,EAAE,EAAE;QACzE,aAAa,MAAM,KAAK,CAAC,WAAW;QACpC,OAAO;IACT;IACA,MAAM,UAAU,MAAM,IAAA,uIAAY,EAAC,KAAK,EAAE,EAAE,MAAM,KAAK,CAAC,WAAW,EAAE,MAAM,OAAO;IAClF,IAAI,CAAC,aAAa,CAAC,SAAS,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO;IAAe,GAAG;QAAE,QAAQ;IAAI;IAEzG,IAAI,YAAY,CAAC,IAAA,4IAAY,EAAC,WAAW;QACvC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAO,OAAO;QAAgB,GAAG;YAAE,QAAQ;QAAI;IAChF;IAEA,IAAI,kBAAiC;IACrC,IAAI,YAAY,OAAO,aAAa,YAAY,UAAW,UAAiC;QAC1F,MAAM,UAAU,AAAC,SAAgC,IAAI;QACrD,MAAM,OAAO,MAAM,OAAO,CAAC,WAAW,UAAU,EAAE;QAClD,IAAI,QAAQ;QACZ,IAAI,QAAQ;QACZ,KAAK,OAAO,CAAC,CAAC;YACZ,MAAM,MAAM;YACZ,IAAI,OAAO,QAAQ,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,CAAC,IAAI,KAAK,GAAG;gBAC5D,MAAM,IAAI,OAAO,IAAI,KAAK;gBAC1B,MAAM,IAAI,OAAO,IAAI,KAAK;gBAC1B,IAAI,IAAI,GAAG,SAAS;qBACf,IAAI,IAAI,GAAG,SAAS;YAC3B;QACF;QACA,IAAI,QAAQ,SAAS,MAAM,UAAU,EAAE,kBAAkB,MAAM,UAAU;QACzE,IAAI,QAAQ,SAAS,MAAM,UAAU,EAAE,kBAAkB,MAAM,UAAU;IAC3E;IAEA,MAAM,UAAU,MAAM,yHAAM,CAAC,UAAU,CAAC,MAAM,CAAC;QAC7C,OAAO;YAAE,IAAI;QAAQ;QACrB,MAAM;YACJ,QAAQ,aAAa,MAAM,MAAM;YACjC,OAAO,YAAY,MAAM,KAAK;YAC9B,WAAW,OAAO,aAAa,YAAY,YAAY,UAAW,WAC9D,AAAC,SAAgC,IAAI,GACrC,MAAM,SAAS;YACnB,iBAAiB,mBAAmB,MAAM,eAAe;YACzD,WAAW,cAAc,MAAM,SAAS;YACxC,aAAa,cAAc,MAAM,WAAW;QAC9C;QACA,SAAS;YACP,UAAU;gBAAE,SAAS;oBAAE,OAAO;wBAAE,SAAS;4BAAE,eAAe;wBAAK;oBAAE;gBAAE;YAAE;YACrE,UAAU;gBAAE,SAAS;oBAAE,OAAO;wBAAE,SAAS;4BAAE,eAAe;wBAAK;oBAAE;gBAAE;YAAE;QACvE;IACF;IAEA,MAAM,kBAAkB;WAClB,CAAC,QAAQ,QAAQ,EAAE,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,SAAS,EAAE,MAAM,CAAC;WAC/D,CAAC,QAAQ,QAAQ,EAAE,SAAS,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,SAAS,EAAE,MAAM,CAAC;KACpE;IAED,yCAAyC;IACzC,MAAM,IAAA,4JAAiB,EAAC;QACtB,SAAS;QACT,SAAS,QAAQ,EAAE;QACnB,SAAS,QAAQ,SAAS,IAAI;QAC9B,SAAS,QAAQ,WAAW,IAAI;IAClC;IAEA,iDAAiD;IACjD,IAAI,iBAAiB;QACnB,MAAM,IAAA,2JAAgB,EAAC,iBAAiB,QAAQ,EAAE,EAAE,QAAQ,OAAO;QACnE,MAAM,IAAA,4JAAiB,EAAC,iBAAiB,QAAQ,EAAE,EAAE,QAAQ,OAAO;QAEpE,8EAA8E;QAC9E,IAAI,QAAQ,SAAS,KAAK,YAAY;YACpC,MAAM,YAAY,MAAM,yHAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;gBACjD,OAAO;oBACL,SAAS,QAAQ,OAAO;oBACxB,WAAW;oBACX,GAAI,QAAQ,UAAU,GAAG;wBAAE,YAAY,QAAQ,UAAU;oBAAC,IAAI,CAAC,CAAC;gBAClE;gBACA,QAAQ;oBAAE,IAAI;oBAAM,YAAY;oBAAM,YAAY;oBAAM,YAAY;oBAAM,iBAAiB;gBAAK;gBAChG,SAAS;oBAAC;wBAAE,YAAY;oBAAM;oBAAG;wBAAE,IAAI;oBAAM;iBAAE;YACjD;YACA,MAAM,aAAa,iBAAiB,WAAW,GAAG,CAAC,CAAC,CAAC,MAAM,GAAK;YAChE,MAAM,YAAY,IAAI;YACtB,WAAW,OAAO,CAAC,CAAC;gBAClB,UAAU,GAAG,CACX,OACA,UAAU,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,UAAU,IAAI,GAAG,MAAM;YAEtD;YAEA,MAAM,UAAU,OAAO,aAAqB;gBAC1C,MAAM,YAAY,UAAU,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;gBACjD,IAAI,CAAC,WAAW;gBAChB,MAAM,eAAe,UAAU,UAAU,IAAI,UAAU,CAAC,EAAE,IAAI;gBAC9D,MAAM,aAAa,WAAW,SAAS,CAAC,CAAC,IAAM,MAAM;gBACrD,IAAI,eAAe,CAAC,KAAK,cAAc,WAAW,MAAM,GAAG,GAAG;gBAC9D,MAAM,iBAAiB,UAAU,GAAG,CAAC,iBAAiB,EAAE;gBACxD,MAAM,iBAAiB,UAAU,CAAC,aAAa,EAAE;gBACjD,MAAM,cAAc,UAAU,GAAG,CAAC,mBAAmB,EAAE;gBACvD,MAAM,aAAa,eAAe,SAAS,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;gBAC5D,IAAI,eAAe,CAAC,GAAG;gBACvB,MAAM,YAAY,KAAK,KAAK,CAAC,aAAa;gBAC1C,MAAM,SAAS,WAAW,CAAC,UAAU;gBACrC,IAAI,CAAC,QAAQ;gBACb,MAAM,eAAwC,CAAC;gBAC/C,IAAI,aAAa,MAAM,GAAG;oBACxB,IAAI,CAAC,OAAO,UAAU,EAAE,aAAa,UAAU,GAAG;yBAC7C,IAAI,CAAC,OAAO,UAAU,EAAE,aAAa,UAAU,GAAG;gBACzD,OAAO;oBACL,IAAI,CAAC,OAAO,UAAU,EAAE,aAAa,UAAU,GAAG;yBAC7C,IAAI,CAAC,OAAO,UAAU,EAAE,aAAa,UAAU,GAAG;gBACzD;gBACA,IAAI,OAAO,IAAI,CAAC,cAAc,MAAM,GAAG,GAAG;oBACxC,MAAM,gBAAgB,MAAM,yHAAM,CAAC,UAAU,CAAC,MAAM,CAAC;wBACnD,OAAO;4BAAE,IAAI,OAAO,EAAE;wBAAC;wBACvB,MAAM;oBACR;oBACA,0BAA0B;oBAC1B,OAAO,UAAU,GAAG,cAAc,UAAU;oBAC5C,OAAO,UAAU,GAAG,cAAc,UAAU;oBAC5C,oBAAoB;oBACpB,IACE,AAAC,cAAc,UAAU,IAAI,CAAC,cAAc,UAAU,IACrD,CAAC,cAAc,UAAU,IAAI,cAAc,UAAU,EACtD;wBACA,MAAM,aAAa,cAAc,UAAU,IAAI,cAAc,UAAU;wBACvE,MAAM,WAAW,MAAM,yHAAM,CAAC,UAAU,CAAC,MAAM,CAAC;4BAC9C,OAAO;gCAAE,IAAI,cAAc,EAAE;4BAAC;4BAC9B,MAAM;gCAAE,iBAAiB;gCAAY,QAAQ;4BAAO;wBACtD;wBACA,OAAO,eAAe,GAAG,SAAS,eAAe;wBACjD,OAAO,UAAU,GAAG,SAAS,UAAU;wBACvC,OAAO,UAAU,GAAG,SAAS,UAAU;wBACvC,MAAM,QAAQ,OAAO,EAAE,EAAE;oBAC3B;gBACF;YACF;YAEA,MAAM,QAAQ,QAAQ,EAAE,EAAE;QAC5B;IACF;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAM,OAAO;IAAQ,GAAG;QAAE,QAAQ;IAAI;AACvE"}}]
}