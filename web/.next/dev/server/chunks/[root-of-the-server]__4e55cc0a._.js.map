{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/env.ts"],"sourcesContent":["// Central helper for server-side environment variables (server-only).\n// ⚠️ Não importar este módulo em componentes com \"use client\".\nconst required = [\n  \"SUPABASE_URL\",\n  \"SUPABASE_ANON_KEY\",\n  \"SUPABASE_SERVICE_ROLE\",\n  \"DATABASE_URL\",\n  \"STRIPE_SECRET_KEY\",\n  \"STRIPE_WEBHOOK_SECRET\",\n  \"QR_SECRET_KEY\",\n  \"RESEND_API_KEY\",\n] as const;\n\ntype EnvKey = (typeof required)[number];\n\nfunction getEnv(key: EnvKey): string {\n  const value = process.env[key];\n  if (!value) {\n    throw new Error(`Missing env var: ${key}`);\n  }\n  return value;\n}\n\nfunction getOptionalUrlEnv(...keys: string[]) {\n  for (const key of keys) {\n    const value = process.env[key];\n    if (typeof value === \"string\" && value.trim().length > 0) {\n      return value.trim().replace(/\\/+$/, \"\"); // remove trailing slash para URLs previsíveis\n    }\n  }\n  return \"\";\n}\n\nfunction parseBoolean(raw: unknown, fallback: boolean) {\n  if (typeof raw === \"boolean\") return raw;\n  if (typeof raw === \"string\") {\n    const normalized = raw.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"on\"].includes(normalized)) return true;\n    if ([\"0\", \"false\", \"no\", \"off\"].includes(normalized)) return false;\n  }\n  return fallback;\n}\n\nfunction parseNumber(raw: unknown, fallback: number) {\n  const n = Number(raw);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction parseList(raw: unknown) {\n  if (typeof raw !== \"string\") return [];\n  return raw\n    .split(/[,\\s]+/g)\n    .map((item) => item.trim())\n    .filter(Boolean);\n}\n\nexport const env = {\n  supabaseUrl: getEnv(\"SUPABASE_URL\"),\n  supabaseAnonKey: getEnv(\"SUPABASE_ANON_KEY\"),\n  serviceRoleKey: getEnv(\"SUPABASE_SERVICE_ROLE\"),\n  dbUrl: getEnv(\"DATABASE_URL\"),\n  stripeSecretKey: getEnv(\"STRIPE_SECRET_KEY\"),\n  stripeWebhookSecret: getEnv(\"STRIPE_WEBHOOK_SECRET\"),\n  qrSecretKey: getEnv(\"QR_SECRET_KEY\"),\n  resendApiKey: getEnv(\"RESEND_API_KEY\"),\n  resendFrom:\n    process.env.RESEND_FROM ??\n    process.env.RESEND_FROM_EMAIL ??\n    \"no-reply@orya.pt\",\n  appBaseUrl: getOptionalUrlEnv(\"APP_BASE_URL\", \"NEXT_PUBLIC_BASE_URL\", \"NEXT_PUBLIC_SITE_URL\", \"VERCEL_URL\"),\n  uploadsBucket:\n    process.env.SUPABASE_STORAGE_BUCKET_UPLOADS ??\n    process.env.SUPABASE_STORAGE_BUCKET ??\n    \"uploads\",\n  avatarsBucket: process.env.SUPABASE_STORAGE_BUCKET_AVATARS ?? \"\",\n  eventCoversBucket: process.env.SUPABASE_STORAGE_BUCKET_EVENT_COVERS ?? \"\",\n  storageSignedUrls: parseBoolean(process.env.SUPABASE_STORAGE_SIGNED_URLS, false),\n  storageSignedTtlSeconds: parseNumber(process.env.SUPABASE_STORAGE_SIGNED_TTL_SECONDS, 60 * 60 * 24 * 30), // 30 dias\n  stripePremiumPriceIds: parseList(process.env.STRIPE_PREMIUM_PRICE_IDS),\n  stripePremiumProductIds: parseList(process.env.STRIPE_PREMIUM_PRODUCT_IDS),\n};\n"],"names":[],"mappings":"AAAA,sEAAsE;AACtE,+DAA+D;;;;;AAC/D,MAAM,WAAW;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAID,SAAS,OAAO,GAAW;IACzB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;IAC9B,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK;IAC3C;IACA,OAAO;AACT;AAEA,SAAS,kBAAkB,GAAG,IAAc;IAC1C,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;QAC9B,IAAI,OAAO,UAAU,YAAY,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG;YACxD,OAAO,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,KAAK,8CAA8C;QACzF;IACF;IACA,OAAO;AACT;AAEA,SAAS,aAAa,GAAY,EAAE,QAAiB;IACnD,IAAI,OAAO,QAAQ,WAAW,OAAO;IACrC,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,aAAa,IAAI,IAAI,GAAG,WAAW;QACzC,IAAI;YAAC;YAAK;YAAQ;YAAO;SAAK,CAAC,QAAQ,CAAC,aAAa,OAAO;QAC5D,IAAI;YAAC;YAAK;YAAS;YAAM;SAAM,CAAC,QAAQ,CAAC,aAAa,OAAO;IAC/D;IACA,OAAO;AACT;AAEA,SAAS,YAAY,GAAY,EAAE,QAAgB;IACjD,MAAM,IAAI,OAAO;IACjB,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEA,SAAS,UAAU,GAAY;IAC7B,IAAI,OAAO,QAAQ,UAAU,OAAO,EAAE;IACtC,OAAO,IACJ,KAAK,CAAC,WACN,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI,IACvB,MAAM,CAAC;AACZ;AAEO,MAAM,MAAM;IACjB,aAAa,OAAO;IACpB,iBAAiB,OAAO;IACxB,gBAAgB,OAAO;IACvB,OAAO,OAAO;IACd,iBAAiB,OAAO;IACxB,qBAAqB,OAAO;IAC5B,aAAa,OAAO;IACpB,cAAc,OAAO;IACrB,YACE,QAAQ,GAAG,CAAC,WAAW,IACvB,QAAQ,GAAG,CAAC,iBAAiB,IAC7B;IACF,YAAY,kBAAkB,gBAAgB,wBAAwB,wBAAwB;IAC9F,eACE,QAAQ,GAAG,CAAC,+BAA+B,IAC3C,QAAQ,GAAG,CAAC,uBAAuB,IACnC;IACF,eAAe,QAAQ,GAAG,CAAC,+BAA+B,IAAI;IAC9D,mBAAmB,QAAQ,GAAG,CAAC,oCAAoC,IAAI;IACvE,mBAAmB,aAAa,QAAQ,GAAG,CAAC,4BAA4B,EAAE;IAC1E,yBAAyB,YAAY,QAAQ,GAAG,CAAC,mCAAmC,EAAE,KAAK,KAAK,KAAK;IACrG,uBAAuB,UAAU,QAAQ,GAAG,CAAC,wBAAwB;IACrE,yBAAyB,UAAU,QAAQ,GAAG,CAAC,0BAA0B;AAC3E"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/supabaseServer.ts"],"sourcesContent":["import \"server-only\";\nimport { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\nimport { env } from \"@/lib/env\";\n\nfunction decodeBase64Cookie(raw: string) {\n  const BASE64_PREFIX = \"base64-\";\n  if (!raw.startsWith(BASE64_PREFIX)) return raw;\n\n  const base = raw.slice(BASE64_PREFIX.length);\n  const encodings: BufferEncoding[] = [\"base64url\", \"base64\"];\n\n  for (const enc of encodings) {\n    try {\n      return Buffer.from(base, enc).toString(\"utf-8\");\n    } catch {\n      /* try next */\n    }\n  }\n\n  // Se não conseguirmos decodificar, tratamos como cookie ausente para evitar JSON.parse de strings inválidas\n  return undefined;\n}\n\n/**\n * Server-side Supabase client (SSR + Route Handlers)\n * - Safe cookie reading\n * - Safe cookie writing\n * - Prevents JSON parse errors\n * - No profile fetching here\n */\nexport async function createSupabaseServer() {\n  const cookieStore = (await cookies());\n\n  const supabase = createServerClient(\n    env.supabaseUrl,\n    env.supabaseAnonKey,\n    {\n      cookies: {\n        get(name: string) {\n          try {\n            // Só devolvemos cookies do Supabase (sb-*) e ignoramos o resto\n            if (!name.startsWith(\"sb-\")) return undefined;\n            const raw = cookieStore.get(name)?.value;\n            if (!raw) return undefined;\n\n            // Se for um chunk (sb-*.0, sb-*.1, ...), deixamos intacto para o combinador do Supabase tratar\n            const isChunk = /\\.\\d+$/.test(name);\n            return isChunk ? raw : decodeBase64Cookie(raw);\n          } catch {\n            return undefined;\n          }\n        },\n        set(name: string, value: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value, ...options });\n          } catch {\n            /* ignore errors for RSC */\n          }\n        },\n        remove(name: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value: \"\", ...options, maxAge: 0 });\n          } catch {\n            /* ignore */\n          }\n        },\n      },\n    }\n  );\n\n  return supabase;\n}\n\n\nexport async function getCurrentUser() {\n  const supabase = await createSupabaseServer();\n\n  try {\n    const { data, error } = await supabase.auth.getUser();\n\n    if (error || !data?.user) {\n      return { user: null, error };\n    }\n\n    return { user: data.user, error: null };\n  } catch (err) {\n    return { user: null, error: err };\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAEA,SAAS,mBAAmB,GAAW;IACrC,MAAM,gBAAgB;IACtB,IAAI,CAAC,IAAI,UAAU,CAAC,gBAAgB,OAAO;IAE3C,MAAM,OAAO,IAAI,KAAK,CAAC,cAAc,MAAM;IAC3C,MAAM,YAA8B;QAAC;QAAa;KAAS;IAE3D,KAAK,MAAM,OAAO,UAAW;QAC3B,IAAI;YACF,OAAO,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,CAAC;QACzC,EAAE,OAAM;QACN,YAAY,GACd;IACF;IAEA,4GAA4G;IAC5G,OAAO;AACT;AASO,eAAe;IACpB,MAAM,cAAe,MAAM,IAAA,4IAAO;IAElC,MAAM,WAAW,IAAA,iMAAkB,EACjC,mHAAG,CAAC,WAAW,EACf,mHAAG,CAAC,eAAe,EACnB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,IAAI;oBACF,+DAA+D;oBAC/D,IAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,OAAO;oBACpC,MAAM,MAAM,YAAY,GAAG,CAAC,OAAO;oBACnC,IAAI,CAAC,KAAK,OAAO;oBAEjB,+FAA+F;oBAC/F,MAAM,UAAU,SAAS,IAAI,CAAC;oBAC9B,OAAO,UAAU,MAAM,mBAAmB;gBAC5C,EAAE,OAAM;oBACN,OAAO;gBACT;YACF;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAgC;gBAC/D,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM;wBAAO,GAAG,OAAO;oBAAC;gBAC5C,EAAE,OAAM;gBACN,yBAAyB,GAC3B;YACF;YACA,QAAO,IAAY,EAAE,OAAgC;gBACnD,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM,OAAO;wBAAI,GAAG,OAAO;wBAAE,QAAQ;oBAAE;gBAC3D,EAAE,OAAM;gBACN,UAAU,GACZ;YACF;QACF;IACF;IAGF,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,WAAW,MAAM;IAEvB,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAEnD,IAAI,SAAS,CAAC,MAAM,MAAM;YACxB,OAAO;gBAAE,MAAM;gBAAM;YAAM;QAC7B;QAEA,OAAO;YAAE,MAAM,KAAK,IAAI;YAAE,OAAO;QAAK;IACxC,EAAE,OAAO,KAAK;QACZ,OAAO;YAAE,MAAM;YAAM,OAAO;QAAI;IAClC;AACF"}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\nimport { Prisma, PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\nimport { env } from \"@/lib/env\";\n\n// Toggle de logs verbose (queries) via env: PRISMA_LOG_QUERIES=true\nconst enableQueryLog = process.env.PRISMA_LOG_QUERIES === \"true\";\nconst logLevels: (Prisma.LogLevel | Prisma.LogDefinition)[] =\n  process.env.NODE_ENV === \"development\"\n    ? enableQueryLog\n      ? [\"query\", \"error\", \"warn\"]\n      : [\"error\", \"warn\"]\n    : [\"error\"];\n\n// Evitar múltiplas instâncias em dev (hot reload)\nconst globalForPrisma = globalThis as unknown as {\n  prisma?: PrismaClient;\n};\n\n// Pool e adapter para usar o client engine (\"library\") com Postgres\nconst pool = new Pool({\n  connectionString: env.dbUrl,\n  ssl:\n    process.env.NODE_ENV === \"production\"\n      ? undefined\n      : { rejectUnauthorized: false },\n});\n\nconst adapter = new PrismaPg(pool);\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    adapter,\n    log: logLevels,\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA;AACA;AACA;;;;;;;;;;AAEA,oEAAoE;AACpE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,kBAAkB,KAAK;AAC1D,MAAM,YACJ,uCACI,iBACE;IAAC;IAAS;IAAS;CAAO,GAC1B;IAAC;IAAS;CAAO,GACnB;AAEN,kDAAkD;AAClD,MAAM,kBAAkB;AAIxB,oEAAoE;AACpE,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,mHAAG,CAAC,KAAK;IAC3B,KACE,sCACI,0BACA;QAAE,oBAAoB;IAAM;AACpC;AAEA,MAAM,UAAU,IAAI,8JAAQ,CAAC;AAEtB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf;IACA,KAAK;AACP;AAEF,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B"}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/tournaments/matchRules.ts"],"sourcesContent":["import { TournamentMatchStatus } from \"@prisma/client\";\n\nexport type SetScore = { a: number; b: number };\nexport type ScorePayload = { sets: SetScore[] };\nexport type GoalScorePayload = { a: number; b: number; limit?: number };\nexport type MatchScorePayload = { sets?: SetScore[]; goals?: GoalScorePayload };\n\nexport type ValidationResult =\n  | { ok: true; winner: \"A\" | \"B\"; normalized: ScorePayload }\n  | { ok: false; code: string; message: string };\n\nexport type GoalValidationResult =\n  | { ok: true; winner: \"A\" | \"B\" | null; status: TournamentMatchStatus; normalized: GoalScorePayload }\n  | { ok: false; code: string; message: string };\n\nconst WIN_BY = 2;\nconst MAX_SETS = 3; // BO3\nconst MIN_GAMES_TO_WIN = 6;\nconst TIEBREAK_GAMES = 7;\n\nfunction isValidSet(set: SetScore) {\n  const a = Number(set.a);\n  const b = Number(set.b);\n  if (!Number.isFinite(a) || !Number.isFinite(b) || a < 0 || b < 0) return false;\n  const max = Math.max(a, b);\n  const diff = Math.abs(a - b);\n  // tiebreak 7-6 é aceite\n  if (max === TIEBREAK_GAMES && diff === 1) return true;\n  if (max >= MIN_GAMES_TO_WIN) return diff >= WIN_BY;\n  return false;\n}\n\nexport function validateScore(score: ScorePayload): ValidationResult {\n  if (!score || !Array.isArray(score.sets) || score.sets.length === 0) {\n    return { ok: false, code: \"INVALID_SCORE\", message: \"Score vazio ou inválido.\" };\n  }\n  if (score.sets.length > MAX_SETS) {\n    return { ok: false, code: \"TOO_MANY_SETS\", message: \"Máximo de 3 sets (BO3).\" };\n  }\n\n  let winsA = 0;\n  let winsB = 0;\n  for (const s of score.sets) {\n    if (!isValidSet(s)) return { ok: false, code: \"INVALID_SET\", message: \"Set inválido.\" };\n    if (s.a > s.b) winsA += 1;\n    else winsB += 1;\n  }\n\n  if (winsA === winsB) return { ok: false, code: \"NO_WINNER\", message: \"Empate não permitido no BO3.\" };\n  if (winsA > MAX_SETS || winsB > MAX_SETS) {\n    return { ok: false, code: \"TOO_MANY_WINS\", message: \"Vitórias a mais para BO3.\" };\n  }\n  if (winsA > winsB && winsA > MAX_SETS - 1) {\n    return { ok: true, winner: \"A\", normalized: score };\n  }\n  if (winsB > winsA && winsB > MAX_SETS - 1) {\n    return { ok: true, winner: \"B\", normalized: score };\n  }\n  return { ok: false, code: \"NO_WINNER\", message: \"Score não determina vencedor.\" };\n}\n\nexport function validateGoalScore(score: GoalScorePayload): GoalValidationResult {\n  const a = Number(score?.a);\n  const b = Number(score?.b);\n  const limit = Number(score?.limit);\n  if (!Number.isFinite(a) || !Number.isFinite(b) || a < 0 || b < 0) {\n    return { ok: false, code: \"INVALID_SCORE\", message: \"Score inválido.\" };\n  }\n  if (!Number.isFinite(limit) || limit <= 0) {\n    return { ok: false, code: \"INVALID_LIMIT\", message: \"Limite de golos inválido.\" };\n  }\n  if (a > limit || b > limit) {\n    return { ok: false, code: \"LIMIT_EXCEEDED\", message: \"Score ultrapassa o limite.\" };\n  }\n  if (a === limit && b === limit) {\n    return { ok: false, code: \"TIE_NOT_ALLOWED\", message: \"Empate não permitido.\" };\n  }\n  if (a === limit) {\n    return { ok: true, winner: \"A\", status: TournamentMatchStatus.DONE, normalized: { a, b, limit } };\n  }\n  if (b === limit) {\n    return { ok: true, winner: \"B\", status: TournamentMatchStatus.DONE, normalized: { a, b, limit } };\n  }\n  if (a > 0 || b > 0) {\n    return { ok: true, winner: null, status: TournamentMatchStatus.IN_PROGRESS, normalized: { a, b, limit } };\n  }\n  return { ok: true, winner: null, status: TournamentMatchStatus.PENDING, normalized: { a, b, limit } };\n}\n\nexport function getWinnerSideFromScore(score?: MatchScorePayload | null) {\n  if (!score) return null;\n  if (score.goals) {\n    const res = validateGoalScore(score.goals);\n    return res.ok ? res.winner : null;\n  }\n  if (Array.isArray(score.sets) && score.sets.length > 0) {\n    const res = validateScore({ sets: score.sets });\n    return res.ok ? res.winner : null;\n  }\n  return null;\n}\n\nexport function canEditMatch(status: TournamentMatchStatus, force?: boolean) {\n  if (force) return true;\n  // não permite editar DONE se não for force\n  return status !== \"DONE\" && status !== \"DISPUTED\";\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/tournaments/matchUpdate.ts"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\nimport { Prisma, TournamentMatchStatus } from \"@prisma/client\";\nimport {\n  validateScore,\n  validateGoalScore,\n  MatchScorePayload,\n  canEditMatch,\n} from \"@/domain/tournaments/matchRules\";\n\ntype UpdateResultInput = {\n  matchId: number;\n  score?: MatchScorePayload;\n  status?: TournamentMatchStatus;\n  explicitWinnerPairingId?: number | null;\n  expectedUpdatedAt?: Date | string | null;\n  userId?: string | null;\n  force?: boolean;\n};\n\nexport async function updateMatchResult({\n  matchId,\n  score,\n  status,\n  explicitWinnerPairingId,\n  expectedUpdatedAt,\n  userId,\n  force = false,\n}: UpdateResultInput) {\n  return prisma.$transaction(async (tx) => {\n    const current = await tx.tournamentMatch.findUnique({\n      where: { id: matchId },\n      include: { stage: { select: { tournamentId: true, tournament: { select: { eventId: true } } } } },\n    });\n    if (!current) throw new Error(\"MATCH_NOT_FOUND\");\n\n    if (!canEditMatch(current.status, force)) {\n      throw new Error(\"MATCH_LOCKED\");\n    }\n\n    if (!expectedUpdatedAt) {\n      throw new Error(\"MISSING_VERSION\");\n    }\n    const expected = new Date(expectedUpdatedAt);\n    if (current.updatedAt.getTime() !== expected.getTime()) {\n      throw new Error(\"MATCH_CONFLICT\");\n    }\n\n    let winnerSide: \"A\" | \"B\" | null = null;\n    let normalizedScore: MatchScorePayload | undefined = undefined;\n    let resolvedStatus: TournamentMatchStatus | undefined = undefined;\n    if (score) {\n      if (score.sets) {\n        const validation = validateScore({ sets: score.sets });\n        if (!validation.ok && !force) {\n          const err = validation;\n          const error = err.code === \"NO_WINNER\" ? \"INVALID_SCORE\" : err.code;\n          throw new Error(error);\n        }\n        if (validation.ok) {\n          winnerSide = validation.winner;\n          normalizedScore = validation.normalized;\n        }\n      } else if (score.goals) {\n        const validation = validateGoalScore(score.goals);\n        if (!validation.ok && !force) {\n          throw new Error(validation.code);\n        }\n        if (validation.ok) {\n          winnerSide = validation.winner;\n          normalizedScore = { goals: validation.normalized };\n          resolvedStatus = validation.status;\n        }\n      } else if (!force) {\n        throw new Error(\"INVALID_SCORE\");\n      }\n    }\n\n    const winnerPairingId =\n      explicitWinnerPairingId ??\n      (winnerSide === \"A\" ? current.pairing1Id ?? null : winnerSide === \"B\" ? current.pairing2Id ?? null : null);\n    const shouldUpdateWinner =\n      typeof explicitWinnerPairingId !== \"undefined\" || typeof score !== \"undefined\";\n    const before = {\n      matchId: current.id,\n      status: current.status,\n      score: current.score,\n      pairing1Id: current.pairing1Id,\n      pairing2Id: current.pairing2Id,\n      updatedAt: current.updatedAt,\n    };\n\n    const newStatus: TournamentMatchStatus = status ?? resolvedStatus ?? \"DONE\";\n    const shouldPropagate = Boolean(\n      winnerPairingId && current.nextMatchId && current.nextSlot && newStatus !== \"DISPUTED\",\n    );\n    const nextMatchBefore =\n      shouldPropagate && current.nextMatchId\n        ? await tx.tournamentMatch.findUnique({\n            where: { id: current.nextMatchId },\n            select: { pairing1Id: true, pairing2Id: true },\n          })\n        : null;\n\n    const updated = await tx.tournamentMatch.update({\n      where: { id: matchId },\n      data: {\n        status: newStatus,\n        score: normalizedScore ?? score ?? current.score,\n      },\n    });\n\n    // Propagar winner para o próximo jogo se houver\n    let propagated = false;\n    let nextSlotBefore: number | null = null;\n    let nextSlotAfter: number | null = null;\n    if (shouldPropagate && current.nextMatchId && current.nextSlot) {\n      nextSlotBefore =\n        current.nextSlot === 1 ? nextMatchBefore?.pairing1Id ?? null : nextMatchBefore?.pairing2Id ?? null;\n      nextSlotAfter = winnerPairingId ?? null;\n      await tx.tournamentMatch.update({\n        where: { id: current.nextMatchId },\n        data: current.nextSlot === 1 ? { pairing1Id: winnerPairingId } : { pairing2Id: winnerPairingId },\n      });\n      propagated = Boolean(winnerPairingId);\n    }\n\n    if (newStatus === \"DONE\") {\n      const tournamentConfig = await tx.tournament.findUnique({\n        where: { id: current.stage.tournamentId },\n        select: { config: true },\n      });\n      const config = (tournamentConfig?.config as Record<string, unknown> | null) ?? {};\n      if (config.featuredMatchId === current.id) {\n        await tx.tournament.update({\n          where: { id: current.stage.tournamentId },\n          data: {\n            config: {\n              ...config,\n              featuredMatchId: null,\n              featuredMatchUpdatedAt: new Date().toISOString(),\n            },\n          },\n        });\n      }\n    }\n\n    // Audit log\n    await tx.tournamentAuditLog.create({\n      data: {\n        tournamentId: current.stage.tournamentId,\n        userId: userId ?? null,\n        action: \"EDIT_MATCH_RESULT\",\n        payloadBefore: before,\n        payloadAfter: {\n          matchId: current.id,\n          status: newStatus,\n          score: normalizedScore ?? score ?? current.score,\n          propagated,\n          nextMatchId: current.nextMatchId,\n          nextSlot: current.nextSlot,\n          nextSlotBefore,\n          nextSlotAfter,\n        },\n      },\n    });\n\n    return updated;\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/app/api/organizador/tournaments/%5Bid%5D/matches/%5BmatchId%5D/result/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createSupabaseServer } from \"@/lib/supabaseServer\";\nimport { prisma } from \"@/lib/prisma\";\nimport { updateMatchResult } from \"@/domain/tournaments/matchUpdate\";\nimport { OrganizerMemberRole, TournamentMatchStatus } from \"@prisma/client\";\n\nasync function getOrganizerRole(userId: string, eventId: number) {\n  const evt = await prisma.event.findUnique({ where: { id: eventId }, select: { organizerId: true } });\n  if (!evt?.organizerId) return null;\n  const member = await prisma.organizerMember.findFirst({\n    where: { organizerId: evt.organizerId, userId },\n    select: { role: true },\n  });\n  return member?.role ?? null;\n}\n\nexport async function POST(req: NextRequest, { params }: { params: Promise<{ id: string; matchId: string }> }) {\n  const resolved = await params;\n  const tournamentId = Number(resolved?.id);\n  const matchId = Number(resolved?.matchId);\n  if (!Number.isFinite(tournamentId) || !Number.isFinite(matchId)) {\n    return NextResponse.json({ ok: false, error: \"INVALID_ID\" }, { status: 400 });\n  }\n\n  const supabase = await createSupabaseServer();\n  const { data, error } = await supabase.auth.getUser();\n  if (error || !data?.user) return NextResponse.json({ ok: false, error: \"UNAUTHENTICATED\" }, { status: 401 });\n\n  const match = await prisma.tournamentMatch.findUnique({\n    where: { id: matchId },\n    include: { stage: { select: { tournamentId: true, tournament: { select: { eventId: true } } } } },\n  });\n  if (!match || match.stage.tournamentId !== tournamentId) {\n    return NextResponse.json({ ok: false, error: \"NOT_FOUND\" }, { status: 404 });\n  }\n\n  const organizerRole = await getOrganizerRole(data.user.id, match.stage.tournament.eventId);\n  const liveOperatorRoles: OrganizerMemberRole[] = [\n    OrganizerMemberRole.OWNER,\n    OrganizerMemberRole.CO_OWNER,\n    OrganizerMemberRole.ADMIN,\n    OrganizerMemberRole.STAFF,\n  ];\n  if (!organizerRole || !liveOperatorRoles.includes(organizerRole)) {\n    return NextResponse.json({ ok: false, error: \"FORBIDDEN\" }, { status: 403 });\n  }\n  const isAdmin =\n    organizerRole === OrganizerMemberRole.OWNER ||\n    organizerRole === OrganizerMemberRole.CO_OWNER ||\n    organizerRole === OrganizerMemberRole.ADMIN;\n  if (match.status === \"DISPUTED\" && !isAdmin) {\n    return NextResponse.json({ ok: false, error: \"FORBIDDEN\" }, { status: 403 });\n  }\n\n  const body = await req.json().catch(() => ({}));\n  const { score, status, winnerPairingId, expectedUpdatedAt, force } = body ?? {};\n  const nextStatus =\n    status && Object.values(TournamentMatchStatus).includes(status) ? (status as TournamentMatchStatus) : undefined;\n\n  try {\n    const updated = await updateMatchResult({\n      matchId,\n      score,\n      status: nextStatus,\n      explicitWinnerPairingId: winnerPairingId,\n      expectedUpdatedAt: expectedUpdatedAt ? new Date(expectedUpdatedAt) : undefined,\n      userId: data.user.id,\n      force: force === true,\n    });\n\n    return NextResponse.json({ ok: true, match: updated }, { status: 200 });\n  } catch (err) {\n    if (err instanceof Error && err.message === \"MATCH_CONFLICT\") {\n      return NextResponse.json({ ok: false, error: \"MATCH_CONFLICT\", code: \"VERSION_CONFLICT\" }, { status: 409 });\n    }\n    if (\n      err instanceof Error &&\n      [\"INVALID_SCORE\", \"INVALID_LIMIT\", \"LIMIT_EXCEEDED\", \"TIE_NOT_ALLOWED\", \"NO_WINNER\"].includes(err.message)\n    ) {\n      return NextResponse.json({ ok: false, error: err.message }, { status: 400 });\n    }\n    if (err instanceof Error && err.message === \"MATCH_LOCKED\") {\n      return NextResponse.json({ ok: false, error: \"MATCH_LOCKED\" }, { status: 409 });\n    }\n    if (err instanceof Error && err.message === \"MISSING_VERSION\") {\n      return NextResponse.json({ ok: false, error: \"MISSING_VERSION\" }, { status: 400 });\n    }\n    if (err instanceof Error && err.message === \"MATCH_NOT_FOUND\") {\n      return NextResponse.json({ ok: false, error: \"NOT_FOUND\" }, { status: 404 });\n    }\n    console.error(\"[match_result] erro\", err);\n    return NextResponse.json({ ok: false, error: \"UPDATE_FAILED\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}