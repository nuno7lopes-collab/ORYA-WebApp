{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/env.ts"],"sourcesContent":["// Central helper for server-side environment variables (server-only).\n// ⚠️ Não importar este módulo em componentes com \"use client\".\nconst required = [\n  \"SUPABASE_URL\",\n  \"SUPABASE_ANON_KEY\",\n  \"SUPABASE_SERVICE_ROLE\",\n  \"DATABASE_URL\",\n  \"STRIPE_SECRET_KEY\",\n  \"STRIPE_WEBHOOK_SECRET\",\n  \"QR_SECRET_KEY\",\n  \"RESEND_API_KEY\",\n] as const;\n\ntype EnvKey = (typeof required)[number];\n\nfunction getEnv(key: EnvKey): string {\n  const value = process.env[key];\n  if (!value) {\n    throw new Error(`Missing env var: ${key}`);\n  }\n  return value;\n}\n\nfunction getOptionalUrlEnv(...keys: string[]) {\n  for (const key of keys) {\n    const value = process.env[key];\n    if (typeof value === \"string\" && value.trim().length > 0) {\n      return value.trim().replace(/\\/+$/, \"\"); // remove trailing slash para URLs previsíveis\n    }\n  }\n  return \"\";\n}\n\nfunction parseBoolean(raw: unknown, fallback: boolean) {\n  if (typeof raw === \"boolean\") return raw;\n  if (typeof raw === \"string\") {\n    const normalized = raw.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"on\"].includes(normalized)) return true;\n    if ([\"0\", \"false\", \"no\", \"off\"].includes(normalized)) return false;\n  }\n  return fallback;\n}\n\nfunction parseNumber(raw: unknown, fallback: number) {\n  const n = Number(raw);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction parseList(raw: unknown) {\n  if (typeof raw !== \"string\") return [];\n  return raw\n    .split(/[,\\s]+/g)\n    .map((item) => item.trim())\n    .filter(Boolean);\n}\n\nexport const env = {\n  supabaseUrl: getEnv(\"SUPABASE_URL\"),\n  supabaseAnonKey: getEnv(\"SUPABASE_ANON_KEY\"),\n  serviceRoleKey: getEnv(\"SUPABASE_SERVICE_ROLE\"),\n  dbUrl: getEnv(\"DATABASE_URL\"),\n  stripeSecretKey: getEnv(\"STRIPE_SECRET_KEY\"),\n  stripeWebhookSecret: getEnv(\"STRIPE_WEBHOOK_SECRET\"),\n  qrSecretKey: getEnv(\"QR_SECRET_KEY\"),\n  resendApiKey: getEnv(\"RESEND_API_KEY\"),\n  resendFrom:\n    process.env.RESEND_FROM ??\n    process.env.RESEND_FROM_EMAIL ??\n    \"no-reply@orya.pt\",\n  appBaseUrl: getOptionalUrlEnv(\"APP_BASE_URL\", \"NEXT_PUBLIC_BASE_URL\", \"NEXT_PUBLIC_SITE_URL\", \"VERCEL_URL\"),\n  uploadsBucket:\n    process.env.SUPABASE_STORAGE_BUCKET_UPLOADS ??\n    process.env.SUPABASE_STORAGE_BUCKET ??\n    \"uploads\",\n  avatarsBucket: process.env.SUPABASE_STORAGE_BUCKET_AVATARS ?? \"\",\n  eventCoversBucket: process.env.SUPABASE_STORAGE_BUCKET_EVENT_COVERS ?? \"\",\n  storageSignedUrls: parseBoolean(process.env.SUPABASE_STORAGE_SIGNED_URLS, false),\n  storageSignedTtlSeconds: parseNumber(process.env.SUPABASE_STORAGE_SIGNED_TTL_SECONDS, 60 * 60 * 24 * 30), // 30 dias\n  stripePremiumPriceIds: parseList(process.env.STRIPE_PREMIUM_PRICE_IDS),\n  stripePremiumProductIds: parseList(process.env.STRIPE_PREMIUM_PRODUCT_IDS),\n};\n"],"names":[],"mappings":"AAAA,sEAAsE;AACtE,+DAA+D;;;;;AAC/D,MAAM,WAAW;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAID,SAAS,OAAO,GAAW;IACzB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;IAC9B,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK;IAC3C;IACA,OAAO;AACT;AAEA,SAAS,kBAAkB,GAAG,IAAc;IAC1C,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,QAAQ,QAAQ,GAAG,CAAC,IAAI;QAC9B,IAAI,OAAO,UAAU,YAAY,MAAM,IAAI,GAAG,MAAM,GAAG,GAAG;YACxD,OAAO,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,KAAK,8CAA8C;QACzF;IACF;IACA,OAAO;AACT;AAEA,SAAS,aAAa,GAAY,EAAE,QAAiB;IACnD,IAAI,OAAO,QAAQ,WAAW,OAAO;IACrC,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,aAAa,IAAI,IAAI,GAAG,WAAW;QACzC,IAAI;YAAC;YAAK;YAAQ;YAAO;SAAK,CAAC,QAAQ,CAAC,aAAa,OAAO;QAC5D,IAAI;YAAC;YAAK;YAAS;YAAM;SAAM,CAAC,QAAQ,CAAC,aAAa,OAAO;IAC/D;IACA,OAAO;AACT;AAEA,SAAS,YAAY,GAAY,EAAE,QAAgB;IACjD,MAAM,IAAI,OAAO;IACjB,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEA,SAAS,UAAU,GAAY;IAC7B,IAAI,OAAO,QAAQ,UAAU,OAAO,EAAE;IACtC,OAAO,IACJ,KAAK,CAAC,WACN,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI,IACvB,MAAM,CAAC;AACZ;AAEO,MAAM,MAAM;IACjB,aAAa,OAAO;IACpB,iBAAiB,OAAO;IACxB,gBAAgB,OAAO;IACvB,OAAO,OAAO;IACd,iBAAiB,OAAO;IACxB,qBAAqB,OAAO;IAC5B,aAAa,OAAO;IACpB,cAAc,OAAO;IACrB,YACE,QAAQ,GAAG,CAAC,WAAW,IACvB,QAAQ,GAAG,CAAC,iBAAiB,IAC7B;IACF,YAAY,kBAAkB,gBAAgB,wBAAwB,wBAAwB;IAC9F,eACE,QAAQ,GAAG,CAAC,+BAA+B,IAC3C,QAAQ,GAAG,CAAC,uBAAuB,IACnC;IACF,eAAe,QAAQ,GAAG,CAAC,+BAA+B,IAAI;IAC9D,mBAAmB,QAAQ,GAAG,CAAC,oCAAoC,IAAI;IACvE,mBAAmB,aAAa,QAAQ,GAAG,CAAC,4BAA4B,EAAE;IAC1E,yBAAyB,YAAY,QAAQ,GAAG,CAAC,mCAAmC,EAAE,KAAK,KAAK,KAAK;IACrG,uBAAuB,UAAU,QAAQ,GAAG,CAAC,wBAAwB;IACrE,yBAAyB,UAAU,QAAQ,GAAG,CAAC,0BAA0B;AAC3E"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/supabaseServer.ts"],"sourcesContent":["import \"server-only\";\nimport { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\nimport { env } from \"@/lib/env\";\n\nfunction decodeBase64Cookie(raw: string) {\n  const BASE64_PREFIX = \"base64-\";\n  if (!raw.startsWith(BASE64_PREFIX)) return raw;\n\n  const base = raw.slice(BASE64_PREFIX.length);\n  const encodings: BufferEncoding[] = [\"base64url\", \"base64\"];\n\n  for (const enc of encodings) {\n    try {\n      return Buffer.from(base, enc).toString(\"utf-8\");\n    } catch {\n      /* try next */\n    }\n  }\n\n  // Se não conseguirmos decodificar, tratamos como cookie ausente para evitar JSON.parse de strings inválidas\n  return undefined;\n}\n\n/**\n * Server-side Supabase client (SSR + Route Handlers)\n * - Safe cookie reading\n * - Safe cookie writing\n * - Prevents JSON parse errors\n * - No profile fetching here\n */\nexport async function createSupabaseServer() {\n  const cookieStore = (await cookies());\n\n  const supabase = createServerClient(\n    env.supabaseUrl,\n    env.supabaseAnonKey,\n    {\n      cookies: {\n        get(name: string) {\n          try {\n            // Só devolvemos cookies do Supabase (sb-*) e ignoramos o resto\n            if (!name.startsWith(\"sb-\")) return undefined;\n            const raw = cookieStore.get(name)?.value;\n            if (!raw) return undefined;\n\n            // Se for um chunk (sb-*.0, sb-*.1, ...), deixamos intacto para o combinador do Supabase tratar\n            const isChunk = /\\.\\d+$/.test(name);\n            return isChunk ? raw : decodeBase64Cookie(raw);\n          } catch {\n            return undefined;\n          }\n        },\n        set(name: string, value: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value, ...options });\n          } catch {\n            /* ignore errors for RSC */\n          }\n        },\n        remove(name: string, options: Record<string, unknown>) {\n          try {\n            cookieStore.set({ name, value: \"\", ...options, maxAge: 0 });\n          } catch {\n            /* ignore */\n          }\n        },\n      },\n    }\n  );\n\n  return supabase;\n}\n\n\nexport async function getCurrentUser() {\n  const supabase = await createSupabaseServer();\n\n  try {\n    const { data, error } = await supabase.auth.getUser();\n\n    if (error || !data?.user) {\n      return { user: null, error };\n    }\n\n    return { user: data.user, error: null };\n  } catch (err) {\n    return { user: null, error: err };\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAEA,SAAS,mBAAmB,GAAW;IACrC,MAAM,gBAAgB;IACtB,IAAI,CAAC,IAAI,UAAU,CAAC,gBAAgB,OAAO;IAE3C,MAAM,OAAO,IAAI,KAAK,CAAC,cAAc,MAAM;IAC3C,MAAM,YAA8B;QAAC;QAAa;KAAS;IAE3D,KAAK,MAAM,OAAO,UAAW;QAC3B,IAAI;YACF,OAAO,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,CAAC;QACzC,EAAE,OAAM;QACN,YAAY,GACd;IACF;IAEA,4GAA4G;IAC5G,OAAO;AACT;AASO,eAAe;IACpB,MAAM,cAAe,MAAM,IAAA,4IAAO;IAElC,MAAM,WAAW,IAAA,iMAAkB,EACjC,mHAAG,CAAC,WAAW,EACf,mHAAG,CAAC,eAAe,EACnB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,IAAI;oBACF,+DAA+D;oBAC/D,IAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,OAAO;oBACpC,MAAM,MAAM,YAAY,GAAG,CAAC,OAAO;oBACnC,IAAI,CAAC,KAAK,OAAO;oBAEjB,+FAA+F;oBAC/F,MAAM,UAAU,SAAS,IAAI,CAAC;oBAC9B,OAAO,UAAU,MAAM,mBAAmB;gBAC5C,EAAE,OAAM;oBACN,OAAO;gBACT;YACF;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAgC;gBAC/D,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM;wBAAO,GAAG,OAAO;oBAAC;gBAC5C,EAAE,OAAM;gBACN,yBAAyB,GAC3B;YACF;YACA,QAAO,IAAY,EAAE,OAAgC;gBACnD,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM,OAAO;wBAAI,GAAG,OAAO;wBAAE,QAAQ;oBAAE;gBAC3D,EAAE,OAAM;gBACN,UAAU,GACZ;YACF;QACF;IACF;IAGF,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,WAAW,MAAM;IAEvB,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAEnD,IAAI,SAAS,CAAC,MAAM,MAAM;YACxB,OAAO;gBAAE,MAAM;gBAAM;YAAM;QAC7B;QAEA,OAAO;YAAE,MAAM,KAAK,IAAI;YAAE,OAAO;QAAK;IACxC,EAAE,OAAO,KAAK;QACZ,OAAO;YAAE,MAAM;YAAM,OAAO;QAAI;IAClC;AACF"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\nimport { Prisma, PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\nimport { env } from \"@/lib/env\";\n\n// Toggle de logs verbose (queries) via env: PRISMA_LOG_QUERIES=true\nconst enableQueryLog = process.env.PRISMA_LOG_QUERIES === \"true\";\nconst logLevels: (Prisma.LogLevel | Prisma.LogDefinition)[] =\n  process.env.NODE_ENV === \"development\"\n    ? enableQueryLog\n      ? [\"query\", \"error\", \"warn\"]\n      : [\"error\", \"warn\"]\n    : [\"error\"];\n\n// Evitar múltiplas instâncias em dev (hot reload)\nconst globalForPrisma = globalThis as unknown as {\n  prisma?: PrismaClient;\n};\n\n// Pool e adapter para usar o client engine (\"library\") com Postgres\nconst pool = new Pool({\n  connectionString: env.dbUrl,\n  ssl:\n    process.env.NODE_ENV === \"production\"\n      ? undefined\n      : { rejectUnauthorized: false },\n});\n\nconst adapter = new PrismaPg(pool);\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    adapter,\n    log: logLevels,\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA;AACA;AACA;;;;;;;;;;AAEA,oEAAoE;AACpE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,kBAAkB,KAAK;AAC1D,MAAM,YACJ,uCACI,iBACE;IAAC;IAAS;IAAS;CAAO,GAC1B;IAAC;IAAS;CAAO,GACnB;AAEN,kDAAkD;AAClD,MAAM,kBAAkB;AAIxB,oEAAoE;AACpE,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,mHAAG,CAAC,KAAK;IAC3B,KACE,sCACI,0BACA;QAAE,oBAAoB;IAAM;AACpC;AAEA,MAAM,UAAU,IAAI,8JAAQ,CAAC;AAEtB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf;IACA,KAAK;AACP;AAEF,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B"}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/domain/tournaments/generation.ts"],"sourcesContent":["import seedrandom from \"seedrandom\";\nimport { prisma } from \"@/lib/prisma\";\nimport { Prisma, TournamentFormat, TournamentMatchStatus, TournamentStageType } from \"@prisma/client\";\n\ntype PairingId = number | null;\n\nexport type RoundRobinMatch = { a: PairingId; b: PairingId };\nexport type RoundRobinSchedule = RoundRobinMatch[][];\n\nexport function generateRoundRobin(pairings: PairingId[], seed?: string): RoundRobinSchedule {\n  const rng = seedrandom(seed || `${Date.now()}`);\n  const players = [...pairings];\n  if (players.length % 2 !== 0) players.push(-1); // bye = -1\n  const n = players.length;\n  const rounds: RoundRobinSchedule = [];\n\n  const arr = [...players];\n  for (let round = 0; round < n - 1; round += 1) {\n    const matches: RoundRobinMatch[] = [];\n    for (let i = 0; i < n / 2; i += 1) {\n      const home = arr[i];\n      const away = arr[n - 1 - i];\n      if (home !== -1 && away !== -1) {\n        // shuffle home/away to vary\n        const swap = rng() > 0.5;\n        matches.push({ a: swap ? away : home, b: swap ? home : away });\n      }\n    }\n    rounds.push(matches);\n    // rotate array except first element\n    const fixed = arr[0];\n    const rest = arr.slice(1);\n    rest.unshift(rest.pop() as number);\n    arr.splice(0, arr.length, fixed, ...rest);\n  }\n  return rounds;\n}\n\nexport type EliminationMatch = { a?: PairingId; b?: PairingId };\nexport type EliminationBracket = EliminationMatch[][];\n\nfunction nextPowerOfTwo(value: number) {\n  let size = 1;\n  while (size < value) size *= 2;\n  return size;\n}\n\nfunction resolveBracketSize(total: number, targetSize?: number | null) {\n  if (targetSize === null || typeof targetSize === \"undefined\") {\n    return nextPowerOfTwo(Math.max(1, total));\n  }\n  const size = Math.trunc(targetSize);\n  if (!Number.isFinite(size) || size <= 0) {\n    throw new Error(\"INVALID_BRACKET_SIZE\");\n  }\n  if ((size & (size - 1)) !== 0) {\n    throw new Error(\"INVALID_BRACKET_SIZE\");\n  }\n  if (total > size) {\n    throw new Error(\"BRACKET_TOO_SMALL\");\n  }\n  return size;\n}\n\nexport function generateSingleElimination(\n  pairings: PairingId[],\n  seed?: string,\n  targetSize?: number | null,\n  preserveOrder?: boolean,\n): EliminationBracket {\n  const rng = seedrandom(seed || `${Date.now()}`);\n  const ordered = preserveOrder ? [...pairings] : [...pairings].sort(() => (rng() > 0.5 ? 1 : -1));\n  const size = resolveBracketSize(ordered.length || 1, targetSize);\n  while (ordered.length < size) ordered.push(undefined as unknown as PairingId);\n\n  const rounds: EliminationBracket = [];\n  let current = ordered;\n  while (current.length > 1) {\n    const matches: EliminationMatch[] = [];\n    for (let i = 0; i < current.length; i += 2) {\n      const a = current[i];\n      const b = current[i + 1];\n      matches.push({ a, b });\n    }\n    rounds.push(matches);\n    current = matches.map((_m, idx) => idx as unknown as PairingId); // placeholders for next round seeds\n  }\n  return rounds;\n}\n\nexport type ABBracket = {\n  main: EliminationBracket;\n  consolation: EliminationBracket;\n};\n\nexport function generateDrawAB(\n  pairings: PairingId[],\n  seed?: string,\n  targetSize?: number | null,\n  preserveOrder?: boolean,\n): ABBracket {\n  // main bracket normal; consolation fed by losers (handled by engine later)\n  const main = generateSingleElimination(pairings, seed, targetSize, preserveOrder);\n  const consolation: EliminationBracket = [];\n  return { main, consolation };\n}\n\nconst CONFIRMED_PAIRING_STATUSES = [\"CONFIRMED_BOTH_PAID\", \"CONFIRMED_CAPTAIN_FULL\"] as const;\n\nexport async function getConfirmedPairings(eventId: number) {\n  const pairings = await prisma.padelPairing.findMany({\n    where: {\n      eventId,\n      lifecycleStatus: { in: CONFIRMED_PAIRING_STATUSES as unknown as Prisma.PadelPairingWhereInput[\"lifecycleStatus\"] },\n    },\n    select: { id: true },\n    orderBy: { id: \"asc\" },\n  });\n  return pairings.map((p) => p.id);\n}\n\ntype PersistOptions = {\n  tournamentId: number;\n  format: TournamentFormat;\n  pairings: Array<number | null>;\n  seed?: string | null;\n  inscriptionDeadlineAt?: Date | null;\n  forceGenerate?: boolean;\n  userId?: string;\n  targetSize?: number | null;\n  preserveOrder?: boolean;\n};\n\nexport async function generateAndPersistTournamentStructure(opts: PersistOptions) {\n  const { tournamentId, format, pairings, seed, inscriptionDeadlineAt, forceGenerate, userId, targetSize, preserveOrder } =\n    opts;\n  const rngSeed = seed || `${Date.now()}`;\n  const participantCount = pairings.filter((id) => typeof id === \"number\").length;\n  const hasParticipants = participantCount > 0;\n  const confirmed = preserveOrder ? pairings : pairings.filter((id) => typeof id === \"number\");\n\n  return prisma.$transaction(async (tx) => {\n    // Deadline: se ainda não passou e não foi forçado, bloqueia\n    if (inscriptionDeadlineAt && new Date() < new Date(inscriptionDeadlineAt) && !forceGenerate) {\n      throw new Error(\"INSCRIPTION_NOT_CLOSED\");\n    }\n\n    const started = await tx.tournamentMatch.count({\n      where: { stage: { tournamentId }, status: { in: [\"IN_PROGRESS\", \"DONE\", \"SCHEDULED\"] as TournamentMatchStatus[] } },\n    });\n    if (started > 0 && !forceGenerate) throw new Error(\"TOURNAMENT_ALREADY_STARTED\");\n\n    await tx.tournamentMatch.deleteMany({ where: { stage: { tournamentId } } });\n    await tx.tournamentGroup.deleteMany({ where: { stage: { tournamentId } } });\n    await tx.tournamentStage.deleteMany({ where: { tournamentId } });\n\n    if (!hasParticipants) return { stagesCreated: 0, matchesCreated: 0, seed: rngSeed };\n\n    let stagesCreated = 0;\n    let matchesCreated = 0;\n\n    const createRoundRobin = async (stageName: string, groupName: string, order: number) => {\n      const stage = await tx.tournamentStage.create({\n        data: { tournamentId, name: stageName, stageType: TournamentStageType.GROUPS, order },\n      });\n      stagesCreated += 1;\n      const group = await tx.tournamentGroup.create({\n        data: { stageId: stage.id, name: groupName, order: 1 },\n      });\n      const rr = generateRoundRobin(confirmed, rngSeed);\n      for (let r = 0; r < rr.length; r += 1) {\n        for (const m of rr[r]) {\n          await tx.tournamentMatch.create({\n            data: {\n              stageId: stage.id,\n              groupId: group.id,\n              pairing1Id: m.a,\n              pairing2Id: m.b,\n              round: r + 1,\n              status: TournamentMatchStatus.PENDING,\n            },\n          });\n          matchesCreated += 1;\n        }\n      }\n    };\n\n    const createBracket = async (stageName: string, bracket: EliminationBracket, order: number) => {\n      const stage = await tx.tournamentStage.create({\n        data: { tournamentId, name: stageName, stageType: TournamentStageType.PLAYOFF, order },\n      });\n      stagesCreated += 1;\n      const roundMatchIds: number[][] = [];\n      for (let r = 0; r < bracket.length; r += 1) {\n        const roundIds: number[] = [];\n        for (const m of bracket[r]) {\n          const created = await tx.tournamentMatch.create({\n            data: {\n              stageId: stage.id,\n              pairing1Id: m.a,\n              pairing2Id: m.b,\n              round: r + 1,\n              status: TournamentMatchStatus.PENDING,\n            },\n          });\n          roundIds.push(created.id);\n          matchesCreated += 1;\n        }\n        roundMatchIds.push(roundIds);\n      }\n      for (let r = 0; r < roundMatchIds.length - 1; r += 1) {\n        const currentRound = roundMatchIds[r];\n        const nextRound = roundMatchIds[r + 1];\n        for (let i = 0; i < currentRound.length; i += 1) {\n          const nextMatchId = nextRound[Math.floor(i / 2)];\n          const nextSlot = i % 2 === 0 ? 1 : 2;\n          await tx.tournamentMatch.update({\n            where: { id: currentRound[i] },\n            data: { nextMatchId, nextSlot },\n          });\n        }\n      }\n      return stage.id;\n    };\n\n    const createClassificationFromBracket = async (sourceBracket: EliminationBracket, order: number) => {\n      const stage = await tx.tournamentStage.create({\n        data: { tournamentId, name: \"Classificação\", stageType: TournamentStageType.CONSOLATION, order },\n      });\n      stagesCreated += 1;\n      // Cria jogos de classificação por round (exceto final), placeholders a preencher após resultados\n      for (let r = 0; r < sourceBracket.length; r += 1) {\n        const matchesInRound = sourceBracket[r];\n        if (matchesInRound.length < 2) continue;\n        const classificationCount = Math.floor(matchesInRound.length / 2);\n        for (let i = 0; i < classificationCount; i += 1) {\n          await tx.tournamentMatch.create({\n            data: {\n              stageId: stage.id,\n              round: r + 1,\n              roundLabel: `Classificação R${r + 1}`,\n              status: TournamentMatchStatus.PENDING,\n            },\n          });\n          matchesCreated += 1;\n        }\n      }\n    };\n\n    // Consolation placeholder: cria stage e matches entre perdedores de primeira ronda\n    const createConsolationFromBracket = async (sourceStageId: number, order: number) => {\n      const stage = await tx.tournamentStage.create({\n        data: { tournamentId, name: \"Consolação\", stageType: TournamentStageType.CONSOLATION, order },\n      });\n      stagesCreated += 1;\n      // Busca jogos da primeira ronda do stage fonte\n      const firstRound = await tx.tournamentMatch.findMany({\n        where: { stageId: sourceStageId, round: 1 },\n        orderBy: { id: \"asc\" },\n      });\n      // Pares de derrotados (placeholder: pairing1/2 losers → um jogo)\n      let roundNum = 1;\n      for (let i = 0; i < firstRound.length; i += 2) {\n        const m1 = firstRound[i];\n        const m2 = firstRound[i + 1];\n        if (!m1 || !m2) continue;\n        await tx.tournamentMatch.create({\n          data: {\n            stageId: stage.id,\n            pairing1Id: m1.pairing1Id ?? m1.pairing2Id ?? null,\n            pairing2Id: m2.pairing1Id ?? m2.pairing2Id ?? null,\n            round: roundNum,\n            status: TournamentMatchStatus.PENDING,\n          },\n        });\n        matchesCreated += 1;\n        roundNum += 1;\n      }\n    };\n\n    if (format === \"GROUPS_PLUS_PLAYOFF\" || format === \"CHAMPIONSHIP_ROUND_ROBIN\" || format === \"NONSTOP_ROUND_ROBIN\") {\n      await createRoundRobin(\"Fase de Grupos\", \"Grupo Único\", 1);\n      if (format === \"GROUPS_PLUS_PLAYOFF\" && participantCount > 2) {\n        const bracket = generateSingleElimination(confirmed, rngSeed, targetSize, preserveOrder);\n        const playoffStageId = await createBracket(\"Playoff\", bracket, 2);\n        // Consolação automática dos derrotados da ronda 1\n        await createConsolationFromBracket(playoffStageId, 3);\n      }\n    } else if (format === \"DRAW_A_B\") {\n      const bracket = generateSingleElimination(confirmed, rngSeed, targetSize, preserveOrder);\n      const mainStageId = await createBracket(\"Quadro Principal\", bracket, 1);\n      // Consolação (Quadro B) a partir dos derrotados da ronda 1\n      await createConsolationFromBracket(mainStageId, 2);\n    } else if (format === \"GROUPS_PLUS_FINALS_ALL_PLACES\") {\n      await createRoundRobin(\"Fase de Grupos\", \"Grupo Único\", 1);\n      const finalsBracket = generateSingleElimination(confirmed, rngSeed, targetSize, preserveOrder);\n      await createBracket(\"Finais por posições\", finalsBracket, 2);\n      await createClassificationFromBracket(finalsBracket, 3);\n    } else if (format === \"MANUAL\") {\n      await tx.tournamentStage.create({\n        data: { tournamentId, name: \"Manual\", stageType: TournamentStageType.PLAYOFF, order: 1 },\n      });\n      stagesCreated += 1;\n    }\n\n    await tx.tournament.update({\n      where: { id: tournamentId },\n      data: { generationSeed: rngSeed, updatedAt: new Date(), generatedAt: new Date(), generatedByUserId: userId || null },\n    });\n\n    // Audit log da geração\n    if (userId) {\n      await tx.tournamentAuditLog.create({\n        data: {\n          tournamentId,\n          userId,\n          action: \"GENERATE_BRACKET\",\n          payloadBefore: Prisma.DbNull,\n          payloadAfter: { format, seed: rngSeed, pairings: confirmed },\n        },\n      });\n    }\n\n    return { stagesCreated, matchesCreated, seed: rngSeed };\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///Users/nuno/orya/ORYA-WebApp/app/api/organizador/tournaments/%5Bid%5D/generate/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createSupabaseServer } from \"@/lib/supabaseServer\";\nimport { generateAndPersistTournamentStructure, getConfirmedPairings } from \"@/domain/tournaments/generation\";\nimport { prisma } from \"@/lib/prisma\";\nimport { TournamentFormat } from \"@prisma/client\";\n\nasync function isOrganizerUser(userId: string, organizerId: number) {\n  const member = await prisma.organizerMember.findFirst({\n    where: {\n      organizerId,\n      userId,\n      role: { in: [\"OWNER\", \"CO_OWNER\", \"ADMIN\"] },\n    },\n    select: { id: true },\n  });\n  return Boolean(member);\n}\n\nexport async function POST(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  const resolved = await params;\n  const id = Number(resolved?.id);\n  if (!Number.isFinite(id)) return NextResponse.json({ ok: false, error: \"INVALID_ID\" }, { status: 400 });\n\n  const supabase = await createSupabaseServer();\n  const { data, error } = await supabase.auth.getUser();\n  if (error || !data?.user) return NextResponse.json({ ok: false, error: \"UNAUTHENTICATED\" }, { status: 401 });\n\n  const tournament = await prisma.tournament.findUnique({\n    where: { id },\n    include: { event: { select: { organizerId: true } } },\n  });\n  if (!tournament) return NextResponse.json({ ok: false, error: \"NOT_FOUND\" }, { status: 404 });\n\n  if (!tournament.event.organizerId) {\n    return NextResponse.json({ ok: false, error: \"NO_ORGANIZER\" }, { status: 400 });\n  }\n\n  const authorized = await isOrganizerUser(data.user.id, tournament.event.organizerId);\n  if (!authorized) return NextResponse.json({ ok: false, error: \"FORBIDDEN\" }, { status: 403 });\n\n  const body = await req.json().catch(() => ({}));\n  const format = (body?.format as TournamentFormat | undefined) ?? tournament.format;\n  const seed = typeof body?.seed === \"string\" ? body.seed : null;\n  const forceGenerate = body?.forceGenerate === true;\n  const source = typeof body?.source === \"string\" ? body.source : null;\n  const bracketSize = Number.isFinite(body?.bracketSize) ? Number(body.bracketSize) : null;\n\n  const config = (tournament.config as Record<string, unknown> | null) ?? {};\n  const manualParticipants = Array.isArray(config.manualParticipants)\n    ? (config.manualParticipants as Array<Record<string, unknown>>)\n    : [];\n  const manualEntries = manualParticipants\n    .map((p) => {\n      const id = Number.isFinite(p.id) ? Number(p.id) : null;\n      const seed = Number.isFinite(p.seed) ? Number(p.seed) : null;\n      return { id, seed };\n    })\n    .filter((p) => typeof p.id === \"number\" && p.id >= -2147483648 && p.id <= 2147483647);\n  const manualIds = manualEntries.map((p) => p.id as number);\n  const configBracketSize = Number.isFinite((config as any).bracketSize) ? Number((config as any).bracketSize) : null;\n\n  let pairingIds: Array<number | null> = await getConfirmedPairings(tournament.eventId);\n  const hasManual = manualIds.length > 0;\n  let preserveOrder = false;\n  if (source === \"manual\" || (hasManual && pairingIds.length === 0)) {\n    preserveOrder = true;\n    const targetSize = bracketSize ?? configBracketSize ?? null;\n    if (targetSize && manualIds.length > targetSize) {\n      return NextResponse.json({ ok: false, error: \"BRACKET_TOO_SMALL\" }, { status: 400 });\n    }\n    if (targetSize) {\n      const slots = Array.from({ length: targetSize }, () => null as number | null);\n      const unseeded: number[] = [];\n      manualEntries.forEach((entry) => {\n        if (typeof entry.seed === \"number\" && entry.seed >= 1 && entry.seed <= targetSize) {\n          const idx = entry.seed - 1;\n          if (slots[idx] === null) {\n            slots[idx] = entry.id as number;\n            return;\n          }\n        }\n        unseeded.push(entry.id as number);\n      });\n      let cursor = 0;\n      unseeded.forEach((id) => {\n        while (cursor < slots.length && slots[cursor] !== null) cursor += 1;\n        if (cursor < slots.length) {\n          slots[cursor] = id;\n          cursor += 1;\n        }\n      });\n      pairingIds = slots;\n    } else {\n      pairingIds = manualIds;\n    }\n  }\n  if (source === \"manual\" && manualIds.length === 0) {\n    return NextResponse.json({ ok: false, error: \"NO_PARTICIPANTS\" }, { status: 400 });\n  }\n\n  try {\n    const result = await generateAndPersistTournamentStructure({\n      tournamentId: tournament.id,\n      format,\n      pairings: pairingIds,\n      seed,\n      inscriptionDeadlineAt: tournament.inscriptionDeadlineAt,\n      forceGenerate,\n      userId: data.user.id,\n      targetSize: bracketSize ?? configBracketSize ?? null,\n      preserveOrder,\n    });\n\n    return NextResponse.json(\n      { ok: true, stagesCreated: result.stagesCreated, matchesCreated: result.matchesCreated, seed: result.seed },\n      { status: 200 },\n    );\n  } catch (err) {\n    if (err instanceof Error && err.message === \"TOURNAMENT_ALREADY_STARTED\") {\n      return NextResponse.json({ ok: false, error: \"TOURNAMENT_ALREADY_STARTED\" }, { status: 409 });\n    }\n    if (err instanceof Error && err.message === \"INSCRIPTION_NOT_CLOSED\") {\n      return NextResponse.json({ ok: false, error: \"INSCRIPTION_NOT_CLOSED\" }, { status: 409 });\n    }\n    if (err instanceof Error && err.message === \"INVALID_BRACKET_SIZE\") {\n      return NextResponse.json({ ok: false, error: \"INVALID_BRACKET_SIZE\" }, { status: 400 });\n    }\n    if (err instanceof Error && err.message === \"BRACKET_TOO_SMALL\") {\n      return NextResponse.json({ ok: false, error: \"BRACKET_TOO_SMALL\" }, { status: 400 });\n    }\n    console.error(\"[tournament_generate] erro\", err);\n    return NextResponse.json({ ok: false, error: \"GENERATION_FAILED\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}