-- Address SSOT (Apple primary) + address_lookups + event/padel link

CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Enums
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_type t
    JOIN pg_namespace n ON n.oid = t.typnamespace
    WHERE n.nspname = 'app_v3' AND t.typname = 'address_source_provider'
  ) THEN
    CREATE TYPE app_v3.address_source_provider AS ENUM (
      'APPLE_MAPS',
      'OSM_PHOTON',
      'OSM_NOMINATIM',
      'MANUAL'
    );
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_type t
    JOIN pg_namespace n ON n.oid = t.typnamespace
    WHERE n.nspname = 'app_v3' AND t.typname = 'address_validation_status'
  ) THEN
    CREATE TYPE app_v3.address_validation_status AS ENUM (
      'RAW',
      'NORMALIZED',
      'VERIFIED'
    );
  END IF;
END $$;

-- Addresses table
CREATE TABLE IF NOT EXISTS app_v3.addresses (
  env text NOT NULL DEFAULT 'prod',
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  formatted_address text NOT NULL,
  canonical jsonb NOT NULL,
  lat double precision NOT NULL,
  lng double precision NOT NULL,
  source_provider app_v3.address_source_provider NOT NULL,
  source_provider_place_id text,
  confidence_score integer NOT NULL DEFAULT 0,
  validation_status app_v3.address_validation_status NOT NULL DEFAULT 'NORMALIZED',
  address_hash text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS addresses_address_hash_uq ON app_v3.addresses(address_hash);
CREATE INDEX IF NOT EXISTS addresses_provider_idx ON app_v3.addresses(source_provider);
CREATE INDEX IF NOT EXISTS addresses_env_idx ON app_v3.addresses(env);

-- Address lookups (providerId -> addressId)
CREATE TABLE IF NOT EXISTS app_v3.address_lookups (
  env text NOT NULL DEFAULT 'prod',
  id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  address_id uuid NOT NULL,
  source_provider app_v3.address_source_provider NOT NULL,
  source_provider_place_id text NOT NULL,
  resolved_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX IF NOT EXISTS address_lookups_provider_place_uq ON app_v3.address_lookups(source_provider, source_provider_place_id);
CREATE INDEX IF NOT EXISTS address_lookups_address_idx ON app_v3.address_lookups(address_id);
CREATE INDEX IF NOT EXISTS address_lookups_env_idx ON app_v3.address_lookups(env);

-- RLS env isolation for new tables
ALTER TABLE app_v3.addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE app_v3.address_lookups ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'app_v3' AND tablename = 'addresses' AND policyname = 'env_isolation'
  ) THEN
    CREATE POLICY env_isolation ON app_v3.addresses
      USING (env = current_setting('app.env', true))
      WITH CHECK (env = current_setting('app.env', true));
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'app_v3' AND tablename = 'address_lookups' AND policyname = 'env_isolation'
  ) THEN
    CREATE POLICY env_isolation ON app_v3.address_lookups
      USING (env = current_setting('app.env', true))
      WITH CHECK (env = current_setting('app.env', true));
  END IF;
END $$;

-- Link to events and padel clubs
ALTER TABLE app_v3.events ADD COLUMN IF NOT EXISTS address_id uuid;
ALTER TABLE app_v3.padel_clubs ADD COLUMN IF NOT EXISTS address_id uuid;

CREATE INDEX IF NOT EXISTS events_address_idx ON app_v3.events(address_id);
CREATE INDEX IF NOT EXISTS padel_clubs_address_idx ON app_v3.padel_clubs(address_id);

-- Backfill padel clubs into addresses (manual baseline)
WITH payload AS (
  SELECT
    pc.id AS club_id,
    pc.env AS env,
    COALESCE(pc.location_formatted_address, pc.address, pc.city, pc.name) AS formatted,
    jsonb_strip_nulls(
      jsonb_build_object(
        'label', COALESCE(pc.location_formatted_address, pc.address, pc.city, pc.name),
        'addressLine1', pc.address,
        'addressLine2', pc.city,
        'city', pc.city
      )
    ) AS canonical,
    COALESCE(pc.lat, 0) AS lat,
    COALESCE(pc.lng, 0) AS lng
  FROM app_v3.padel_clubs pc
),
payload_with_hash AS (
  SELECT
    club_id,
    env,
    formatted,
    canonical,
    lat,
    lng,
    encode(digest(canonical::text || ':' || lat::text || ':' || lng::text, 'sha256'), 'hex') AS address_hash
  FROM payload
),
ins AS (
  INSERT INTO app_v3.addresses (
    env,
    formatted_address,
    canonical,
    lat,
    lng,
    source_provider,
    source_provider_place_id,
    confidence_score,
    validation_status,
    address_hash
  )
  SELECT
    env,
    formatted,
    canonical,
    lat,
    lng,
    'MANUAL'::app_v3.address_source_provider,
    NULL,
    20,
    'RAW'::app_v3.address_validation_status,
    address_hash
  FROM payload_with_hash
  ON CONFLICT (address_hash)
  DO UPDATE SET updated_at = now()
  RETURNING id, address_hash
)
UPDATE app_v3.padel_clubs pc
SET address_id = ins.id
FROM payload_with_hash p
JOIN ins ON ins.address_hash = p.address_hash
WHERE pc.id = p.club_id;

ALTER TABLE app_v3.padel_clubs ALTER COLUMN address_id SET NOT NULL;

-- FKs (NOT VALID for safe rollout)
ALTER TABLE app_v3.padel_clubs
  ADD CONSTRAINT padel_clubs_address_fk
  FOREIGN KEY (address_id) REFERENCES app_v3.addresses(id)
  ON DELETE NO ACTION
  NOT VALID;

ALTER TABLE app_v3.events
  ADD CONSTRAINT events_address_fk
  FOREIGN KEY (address_id) REFERENCES app_v3.addresses(id)
  ON DELETE SET NULL
  NOT VALID;
